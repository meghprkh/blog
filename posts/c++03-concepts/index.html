<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>C++20 Concepts in C++03</title><link rel=stylesheet href=../../css/style.css></head><body><header class=site-header><h1>Megh's Blog</h1><nav><ul><li><a href=../../>Home</a></li><li><a href=../../categories>Categories</a></li><li><a href=../../tags>Tags</a></li><li><a href=../../about>About</a></li><li><a href=../../index.xml>Feed</a></li></ul></nav></header><main><article class=post><h1 class=title>C++20 Concepts in C++03</h1><div class=article-details><time>Thu Aug 4 2022</time>
in
<a href=../../categories/c++>C++</a></div><div><nav id=TableOfContents><ul><li><a href=#what-are-c-concepts>What are C++ Concepts</a></li><li><a href=#c03-concepts>C++03 Concepts</a></li><li><a href=#aside-explicit-concepts-in-c20>Aside: Explicit concepts in C++20</a></li><li><a href=#rant-on-c20-concepts>Rant on C++20 Concepts</a></li><li><a href=#extra-syntactic-sugar-stuff>Extra syntactic sugar stuff</a></li><li><a href=#summary>Summary</a></li></ul></nav><p>C++20 Concepts are a new language feature that ease generic programming, but are primarily syntactic sugar.</p><p>We will try to implement them in C++03, with one caveat - we must <em>explicitly specify that a class implements an concept</em>.</p><p><strong>NOTE</strong>: We will use template specialization and do not need to be able to modify the class or our concept for this.</p><p><strong>NOTE</strong>: If it seems like the caveat ignores the entire point of concepts, call these &ldquo;pseudo-minimal-rust-traits&rdquo; and read on. By the end of the article, as the Zen of Python mentions, I promise you will agree that explicit is better than implicit :P</p><h2 id=what-are-c-concepts>What are C++ Concepts</h2><p>C++ Concepts allow us to do compile-time dispatch of methods.</p><p>This compile-time dispatch is thus kind of like Rust traits. (Rust traits provide other features too.)</p><div class=code-play-button><a href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siY29tcGlsZXJzIjpbeyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKysyMCJ9XSwiZXhlY3V0b3JzIjpbeyJhcmd1bWVudHMiOiIiLCJjb21waWxlciI6eyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKysyMCJ9LCJjb21waWxlck91dHB1dFZpc2libGUiOiJ0cnVlIn1dLCJpZCI6MSwibGFuZ3VhZ2UiOiJjKysiLCJzb3VyY2UiOiIjaW5jbHVkZSBcdTAwM2Npb3N0cmVhbVx1MDAzZVxuI2luY2x1ZGUgXHUwMDNjY29uY2VwdHNcdTAwM2VcblxuLy8gRGVmaW5lIHRoZSBjb25jZXB0IGNoZWNrXG50ZW1wbGF0ZSBcdTAwM2N0eXBlbmFtZSBTZWxmXHUwMDNlXG5jb25jZXB0IENvdW50ZXIgPSByZXF1aXJlcyhTZWxmIGNvdW50ZXIsIGludCBuZXdfY291bnQpIHtcbiAgICB7IGNvdW50ZXIuZ2V0X2NvdW50KCkgfSAtXHUwMDNlIHN0ZDo6c2FtZV9hc1x1MDAzY2ludFx1MDAzZTtcbiAgICB7IGNvdW50ZXIuc2V0X2NvdW50KG5ld19jb3VudCkgfSAtXHUwMDNlIHN0ZDo6c2FtZV9hc1x1MDAzY3ZvaWRcdTAwM2U7XG4gICAgeyBTZWxmOjptYXhfY291bnQoKSB9IC1cdTAwM2Ugc3RkOjpzYW1lX2FzXHUwMDNjaW50XHUwMDNlO1xufTtcblxuLy8gT3VyIHN0cnVjdFxuc3RydWN0IE15Q291bnRlciB7XG4gICAgaW50IGNvdW50O1xuXG4gICAgaW50IGdldF9jb3VudCgpIHsgcmV0dXJuIGNvdW50OyB9XG4gICAgdm9pZCBzZXRfY291bnQoaW50IG5ld19jb3VudCkgeyBjb3VudCA9IG5ld19jb3VudDsgfVxuICAgIHN0YXRpYyBpbnQgbWF4X2NvdW50KCkgeyByZXR1cm4gMTAwOyB9XG59O1xuc3RhdGljX2Fzc2VydChDb3VudGVyXHUwMDNjTXlDb3VudGVyXHUwMDNlKTsgLy8gb3B0aW9uYWxseSBjaGVjayBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmb3Jnb3QgYW55IG1ldGhvZHMsIGV0Yy4uLlxuXG4vLyBFeGFtcGxlIHVzYWdlXG50ZW1wbGF0ZSBcdTAwM2N0eXBlbmFtZSBUXHUwMDNlXG5yZXF1aXJlcyBDb3VudGVyXHUwMDNjVFx1MDAzZVxudm9pZCBwcmludF9jb3VudGVyKFRcdTAwMjYgY291bnRlcikge1xuICAgIC8vIENhbiBhbHNvIHVzZSBzaG9ydGhhbmQgYHRlbXBsYXRlIFx1MDAzY0NvdW50ZXIgVFx1MDAzZWAgaW5zdGVhZCBvZiBgcmVxdWlyZXNgIGNsYXVzZVxuICAgIHN0ZDo6Y291dCBcdTAwM2NcdTAwM2MgXCJDb3VudGVyIHdpdGggY291bnQgXCIgXHUwMDNjXHUwMDNjIGNvdW50ZXIuZ2V0X2NvdW50KCkgXHUwMDNjXHUwMDNjIHN0ZDo6ZW5kbDtcbn1cblxuLy8gY29tcGlsZS10aW1lIGRpc3BhdGNoIGFub3RoZXIgbWV0aG9kXG52b2lkIHByaW50X2NvdW50ZXIoaW50IGNvdW50ZXIpIHtcbiAgICBzdGQ6OmNvdXQgXHUwMDNjXHUwMDNjIFwiSW50ZWdlciBjb3VudGVyIHdpdGggY291bnQgXCIgXHUwMDNjXHUwMDNjIGNvdW50ZXIgXHUwMDNjXHUwMDNjIHN0ZDo6ZW5kbDtcbn1cblxuLy8gU2hvcnRoYW5kIHN5bnRheFxudm9pZCBwcmludF9jb3VudGVyX3Nob3J0aGFuZChDb3VudGVyIGF1dG8gY291bnRlcikgeyBwcmludF9jb3VudGVyKGNvdW50ZXIpOyB9XG5cbmludCBtYWluKCkge1xuICAgIE15Q291bnRlciBjIHsgMjUgfTtcbiAgICBwcmludF9jb3VudGVyKGMpO1xuICAgIHByaW50X2NvdW50ZXIoMTApOyAvLyBQcmludHMgSW50ZWdlciBjb3VudGVyXG4gICAgcHJpbnRfY291bnRlcl9zaG9ydGhhbmQoYyk7XG59In1dfQ==" target=_blank>&#9654;</a></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Define the concept check
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>concept</span> Counter <span style=color:#f92672>=</span> <span style=color:#66d9ef>requires</span>(Self counter, <span style=color:#66d9ef>int</span> new_count) {
    { counter.get_count() } <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>same_as<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>;
    { counter.set_count(new_count) } <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>same_as<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>;
    { Self<span style=color:#f92672>::</span>max_count() } <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>same_as<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>;
};

<span style=color:#75715e>// Our struct
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyCounter</span> {
    <span style=color:#66d9ef>int</span> count;

    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get_count</span>() { <span style=color:#66d9ef>return</span> count; }
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_count</span>(<span style=color:#66d9ef>int</span> new_count) { count <span style=color:#f92672>=</span> new_count; }
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max_count</span>() { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>100</span>; }
};
<span style=color:#66d9ef>static_assert</span>(Counter<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span>); <span style=color:#75715e>// optionally check implementation
</span><span style=color:#75715e></span>                                   <span style=color:#75715e>// if we forgot any methods, etc...
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Example usage
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>requires</span> Counter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>void</span> print_counter(T<span style=color:#f92672>&amp;</span> counter) {
    <span style=color:#75715e>// Can also use shorthand `template &lt;Counter T&gt;` instead of `requires` clause
</span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Counter with count &#34;</span> <span style=color:#f92672>&lt;&lt;</span> counter.get_count() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
}

<span style=color:#75715e>// compile-time dispatch another method
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_counter</span>(<span style=color:#66d9ef>int</span> counter) {
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Integer counter with count &#34;</span> <span style=color:#f92672>&lt;&lt;</span> counter <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
}

<span style=color:#75715e>// Shorthand syntax
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_counter_shorthand</span>(Counter <span style=color:#66d9ef>auto</span> counter) { print_counter(counter); }

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    MyCounter c { <span style=color:#ae81ff>25</span> };
    print_counter(c);
    print_counter(<span style=color:#ae81ff>10</span>); <span style=color:#75715e>// Prints Integer counter
</span><span style=color:#75715e></span>    print_counter_shorthand(c);
}
</code></pre></div><p>Notice that we never needed to specify that <code>MyCounter</code> implements <code>Counter</code>. This can easily be fixed by requiring some constant to be defined in <code>MyCounter</code> or otherwise.</p><p>We call the above <strong>&ldquo;implicit concepts&rdquo;</strong>. We will try to implement <strong>&ldquo;explicit concepts&rdquo;</strong> - where something must specify that the concept has been implemented for a class.</p><h2 id=c03-concepts>C++03 Concepts</h2><p>We will use C++11 initially. Then will also modify this using some macros for C++03.</p><p>We use a templated struct and observe that <code>static_asserts</code> inside it are executed when the template is specialized.</p><div class=code-play-button><a href=https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siY29tcGlsZXJzIjpbeyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKysxMSJ9XSwiZXhlY3V0b3JzIjpbeyJhcmd1bWVudHMiOiIiLCJjb21waWxlciI6eyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKysxMSJ9LCJjb21waWxlck91dHB1dFZpc2libGUiOiJ0cnVlIn1dLCJpZCI6MSwibGFuZ3VhZ2UiOiJjKysiLCJzb3VyY2UiOiIjaW5jbHVkZSBcdTAwM2Npb3N0cmVhbVx1MDAzZVxuI2luY2x1ZGUgXHUwMDNjdHlwZV90cmFpdHNcdTAwM2VcblxuLy8gRGVmaW5lIHRoZSBjb25jZXB0XG5zdHJ1Y3QgQ291bnRlciB7XG4gICAgLy8gVGhpcyB0ZW1wbGF0ZSBpcyBzcGVjaWFsaXplZCB0byB0cnVlX3R5cGUgYnkgYW55IGNsYXNzIHRoYXRcbiAgICAvLyBpbXBsZW1lbnRzIHRoaXMuIFNwZWNpYWxpemF0aW9uIHJlcXVpcmVzIG93bmVyc2hpcCBvZiBuZWl0aGVyXG4gICAgLy8gQ291bnRlciBjb25jZXB0IG9yIFNlbGYgKFNlbGYgYmVpbmcgdGhlIGNsYXNzIGluIHF1ZXN0aW9uKVxuICAgIHRlbXBsYXRlIFx1MDAzY3R5cGVuYW1lIFNlbGZcdTAwM2VcbiAgICBzdHJ1Y3QgaXNfaW1wbGVtZW50ZWRfYnk6IHN0ZDo6ZmFsc2VfdHlwZSB7fTtcblxuICAgIC8vIERlZmluZSB0aGUgY2hlY2tcbiAgICB0ZW1wbGF0ZSBcdTAwM2N0eXBlbmFtZSBTZWxmXHUwMDNlXG4gICAgc3RydWN0IGNoZWNrOiBzdGQ6OnRydWVfdHlwZSB7XG4gICAgICAgIHN0YXRpY19hc3NlcnQoc3RhdGljX2Nhc3RcdTAwM2MgaW50IChTZWxmOjoqKSgpIFx1MDAzZShcdTAwMjZTZWxmOjpnZXRfY291bnQpKTtcbiAgICAgICAgc3RhdGljX2Fzc2VydChzdGF0aWNfY2FzdFx1MDAzYyB2b2lkIChTZWxmOjoqKShpbnQpIFx1MDAzZShcdTAwMjZTZWxmOjpzZXRfY291bnQpKTtcbiAgICAgICAgc3RhdGljX2Fzc2VydChzdGF0aWNfY2FzdFx1MDAzYyBpbnQgKCopKCkgXHUwMDNlKFx1MDAyNlNlbGY6Om1heF9jb3VudCkpO1xuICAgIH07XG59O1xuXG4vLyBEZWZpbmUgb3VyIHN0cnVjdCBub3JtYWxseSwgd2l0aG91dCBhbnkgbW9kaWZpY2F0aW9uc1xuc3RydWN0IE15Q291bnRlciB7XG4gICAgaW50IGNvdW50O1xuXG4gICAgaW50IGdldF9jb3VudCgpIHsgcmV0dXJuIGNvdW50OyB9XG4gICAgdm9pZCBzZXRfY291bnQoaW50IG5ld19jb3VudCkgeyBjb3VudCA9IG5ld19jb3VudDsgfVxuICAgIHN0YXRpYyBpbnQgbWF4X2NvdW50KCkgeyByZXR1cm4gMTAwOyB9XG59O1xuLy8gRGVjbGFyZSBhbmQgY2hlY2sgdGhhdCB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSB0cmFpdFxudGVtcGxhdGVcdTAwM2NcdTAwM2VcbnN0cnVjdCBDb3VudGVyOjppc19pbXBsZW1lbnRlZF9ieVx1MDAzY015Q291bnRlclx1MDAzZTogQ291bnRlcjo6Y2hlY2tcdTAwM2NNeUNvdW50ZXJcdTAwM2Uge307XG5cbi8vIEV4YW1wbGUgdXNhZ2UgdXNpbmcgY2xhc3NpYyBlbmFibGVfaWYgU0ZJTkFFLiBWZXJib3NlIHlldCBjb252ZW50aW9uYWxcbnRlbXBsYXRlIFx1MDAzY3R5cGVuYW1lIFRcdTAwM2VcbnR5cGVuYW1lIHN0ZDo6ZW5hYmxlX2lmXHUwMDNjXG4gICAgQ291bnRlcjo6aXNfaW1wbGVtZW50ZWRfYnlcdTAwM2NUXHUwMDNlOjp2YWx1ZSxcbnZvaWQgXHUwMDNlOjp0eXBlXG5wcmludF9jb3VudGVyKFRcdTAwMjYgY291bnRlcikge1xuICAgIHN0ZDo6Y291dCBcdTAwM2NcdTAwM2MgXCJDb3VudGVyIHdpdGggY291bnQgXCIgXHUwMDNjXHUwMDNjIGNvdW50ZXIuZ2V0X2NvdW50KCkgXHUwMDNjXHUwMDNjIHN0ZDo6ZW5kbDtcbn1cblxuLy8gY29tcGlsZS10aW1lIGRpc3BhdGNoIGFub3RoZXIgbWV0aG9kXG52b2lkIHByaW50X2NvdW50ZXIoaW50IGNvdW50ZXIpIHtcbiAgICBzdGQ6OmNvdXQgXHUwMDNjXHUwMDNjIFwiSW50ZWdlciBjb3VudGVyIHdpdGggY291bnQgXCIgXHUwMDNjXHUwMDNjIGNvdW50ZXIgXHUwMDNjXHUwMDNjIHN0ZDo6ZW5kbDtcbn1cblxuaW50IG1haW4oKSB7XG4gICAgTXlDb3VudGVyIGNvdW50ZXIgeyAyNSB9O1xuICAgIHByaW50X2NvdW50ZXIoY291bnRlcik7XG4gICAgcHJpbnRfY291bnRlcigxMCk7IC8vIFByaW50cyBJbnRlZ2VyIGNvdW50ZXJcbn0ifV19 target=_blank>&#9654;</a></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Define the concept
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span> {
    <span style=color:#75715e>// This template is specialized to true_type by any class that
</span><span style=color:#75715e></span>    <span style=color:#75715e>// implements this. Specialization requires ownership of neither
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Counter concept or Self (Self being the class in question)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_implemented_by</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>false_type {};

    <span style=color:#75715e>// Define the check
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>check</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>true_type {
        <span style=color:#66d9ef>static_assert</span>(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int</span> (Self<span style=color:#f92672>::*</span>)() <span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>Self<span style=color:#f92672>::</span>get_count));
        <span style=color:#66d9ef>static_assert</span>(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> (Self<span style=color:#f92672>::*</span>)(<span style=color:#66d9ef>int</span>) <span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>Self<span style=color:#f92672>::</span>set_count));
        <span style=color:#66d9ef>static_assert</span>(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>)() <span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>Self<span style=color:#f92672>::</span>max_count));
    };
};

<span style=color:#75715e>// Define our struct normally, without any modifications
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyCounter</span> {
    <span style=color:#66d9ef>int</span> count;

    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get_count</span>() { <span style=color:#66d9ef>return</span> count; }
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_count</span>(<span style=color:#66d9ef>int</span> new_count) { count <span style=color:#f92672>=</span> new_count; }
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max_count</span>() { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>100</span>; }
};
<span style=color:#75715e>// Declare and check that we have implemented the trait
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span><span style=color:#f92672>::</span>is_implemented_by<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;:</span> Counter<span style=color:#f92672>::</span>check<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span> {};

<span style=color:#75715e>// Example usage using classic enable_if SFINAE. Verbose yet conventional
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>typename</span> std<span style=color:#f92672>::</span>enable_if<span style=color:#f92672>&lt;</span>
    Counter<span style=color:#f92672>::</span>is_implemented_by<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>value,
<span style=color:#66d9ef>void</span> <span style=color:#f92672>&gt;::</span>type
print_counter(T<span style=color:#f92672>&amp;</span> counter) {
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Counter with count &#34;</span> <span style=color:#f92672>&lt;&lt;</span> counter.get_count() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
}

<span style=color:#75715e>// compile-time dispatch another method
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_counter</span>(<span style=color:#66d9ef>int</span> counter) {
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Integer counter with count &#34;</span> <span style=color:#f92672>&lt;&lt;</span> counter <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    MyCounter counter { <span style=color:#ae81ff>25</span> };
    print_counter(counter);
    print_counter(<span style=color:#ae81ff>10</span>); <span style=color:#75715e>// Prints Integer counter
</span><span style=color:#75715e></span>}
</code></pre></div><p>To do this in C++03, and make it work with C++11 too, lets sprinkle some macros.</p><div class=code-play-button><a href=https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siY29tcGlsZXJzIjpbeyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKyswMyJ9XSwiZXhlY3V0b3JzIjpbeyJhcmd1bWVudHMiOiIiLCJjb21waWxlciI6eyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKyswMyJ9LCJjb21waWxlck91dHB1dFZpc2libGUiOiJ0cnVlIn1dLCJpZCI6MSwibGFuZ3VhZ2UiOiJjKysiLCJzb3VyY2UiOiIjaW5jbHVkZSBcdTAwM2Npb3N0cmVhbVx1MDAzZVxuXG4jaWYgX19jcGx1c3BsdXMgIT0gMTk5NzExTFxuI2luY2x1ZGUgXHUwMDNjdHlwZV90cmFpdHNcdTAwM2VcbiNlbHNlXG4vLyBNb25rZXkgcGF0Y2ggc3RkIGZvciB0aGUgc2FrZSBvZiB0aGUgZXhhbXBsZVxuLy8gQ2FuIHVzZSB5b3VyIGZhdm91cml0ZSB1dGlsaXR5IGxpYnJhcnkgaW5zdGVhZFxubmFtZXNwYWNlIHN0ZCB7XG4gICAgc3RydWN0IHRydWVfdHlwZSB7IHN0YXRpYyBjb25zdCBib29sIHZhbHVlID0gdHJ1ZTsgfTtcbiAgICBzdHJ1Y3QgZmFsc2VfdHlwZSB7IHN0YXRpYyBjb25zdCBib29sIHZhbHVlID0gdHJ1ZTsgfTtcbiAgICB0ZW1wbGF0ZSBcdTAwM2Nib29sIENvbmQsIHR5cGVuYW1lIFR5cGUgPSB2b2lkXHUwMDNlXG4gICAgc3RydWN0IGVuYWJsZV9pZiB7IHR5cGVkZWYgVHlwZSB0eXBlOyB9O1xuICAgIHRlbXBsYXRlIFx1MDAzY3R5cGVuYW1lIFR5cGVcdTAwM2VcbiAgICBzdHJ1Y3QgZW5hYmxlX2lmXHUwMDNjZmFsc2UsIFR5cGVcdTAwM2UgeyB9O1xufVxuI2VuZGlmXG5cbiNkZWZpbmUgX0NPTkNFUFRfVE9LRU5QQVNURSh4LCB5KSB4ICMjIHlcbiNkZWZpbmUgX0NPTkNFUFRfVE9LRU5QQVNURTIoeCwgeSkgX0NPTkNFUFRfVE9LRU5QQVNURSh4LCB5KVxuXG4jaWYgX19jcGx1c3BsdXMgIT0gMTk5NzExTFxuXG4jZGVmaW5lIENPTkNFUFRfQ0hFQ0tfQkVHSU4gXFxcbiAgICB0ZW1wbGF0ZSBcdTAwM2N0eXBlbmFtZSBTZWxmXHUwMDNlIFxcXG4gICAgc3RydWN0IGNoZWNrOiBzdGQ6OnRydWVfdHlwZSB7IFxcXG5cbiNkZWZpbmUgQ09OQ0VQVF9DSEVDS19FTkQgfTtcblxuI2RlZmluZSBDT05DRVBUX0FTU0VSVCBzdGF0aWNfYXNzZXJ0XG5cbiNkZWZpbmUgSU1QTF9DT05DRVBUKENPTkNFUFQsIENMUykgXFxcbiAgICB0ZW1wbGF0ZVx1MDAzY1x1MDAzZSBcXFxuICAgIHN0cnVjdCBDT05DRVBUOjppc19pbXBsZW1lbnRlZF9ieVx1MDAzY0NMU1x1MDAzZTogQ09OQ0VQVDo6Y2hlY2tcdTAwM2NDTFNcdTAwM2Uge307IFxcXG5cbiNlbHNlXG5cbi8vIEluIEMrKzAzIHdlIGRvbnQgaGF2ZSBzdGF0aWNfYXNzZXJ0IGFuZCB3ZSBjYW5ub3QgdXNlIFwiXHUwMDI2VDo6bWV0aG9kXCJcbi8vIGluc2lkZSBzYXkgYSBCT09TVF9TVEFUSUNfQVNTRVJULlxuLy8gV2UganVzdCBkZWZpbmUgYWxsIG9mIHRoZSBjaGVja3MgaW5zaWRlIHRoZSBjb25zdHJ1Y3RvciBvZiBgY2hlY2tgLlxuLy8gVGhlbiBpbiBgSU1QTF9DT05DRVBUYCB3ZSBpbnN0YW50aWF0ZSBhIHN0YXRpYyBvYmplY3Qgb2YgdGhlIHNhbWUuXG5cbiNkZWZpbmUgQ09OQ0VQVF9DSEVDS19CRUdJTiBcXFxuICAgIHRlbXBsYXRlIFx1MDAzY3R5cGVuYW1lIFNlbGZcdTAwM2UgXFxcbiAgICBzdHJ1Y3QgY2hlY2s6IHN0ZDo6dHJ1ZV90eXBlIHsgXFxcbiAgICAgICAgY2hlY2soKSB7IFxcXG5cbiNkZWZpbmUgQ09OQ0VQVF9DSEVDS19FTkQgfSB9O1xuXG52b2lkIF9jb25jZXB0X2Fzc2VydChib29sKSB7fVxuI2RlZmluZSBDT05DRVBUX0FTU0VSVCBfY29uY2VwdF9hc3NlcnRcblxuI2RlZmluZSBJTVBMX0NPTkNFUFQoQ09OQ0VQVCwgQ0xTKSBcXFxuICAgIHRlbXBsYXRlXHUwMDNjXHUwMDNlIFxcXG4gICAgc3RydWN0IENPTkNFUFQ6OmlzX2ltcGxlbWVudGVkX2J5XHUwMDNjQ0xTXHUwMDNlOiBDT05DRVBUOjpjaGVja1x1MDAzY0NMU1x1MDAzZSB7fTsgXFxcbiAgICBzdGF0aWMgQ09OQ0VQVDo6Y2hlY2tcdTAwM2NDTFNcdTAwM2UgX0NPTkNFUFRfVE9LRU5QQVNURTIoX2NvbmNlcHRfY2hlY2tfLCBfX0xJTkVfXyk7IFxcXG5cbiNlbmRpZlxuXG4vLyBEZWZpbmUgdGhlIGNvbmNlcHRcbnN0cnVjdCBDb3VudGVyIHtcbiAgICB0ZW1wbGF0ZSBcdTAwM2N0eXBlbmFtZSBUXHUwMDNlXG4gICAgc3RydWN0IGlzX2ltcGxlbWVudGVkX2J5OiBzdGQ6OmZhbHNlX3R5cGUge307XG5cbiAgICAvLyBEZWZpbmUgdGhlIGNoZWNrXG4gICAgQ09OQ0VQVF9DSEVDS19CRUdJTlxuICAgICAgICBDT05DRVBUX0FTU0VSVChzdGF0aWNfY2FzdFx1MDAzYyBpbnQgKFNlbGY6OiopKCkgXHUwMDNlKFx1MDAyNlNlbGY6OmdldF9jb3VudCkpO1xuICAgICAgICBDT05DRVBUX0FTU0VSVChzdGF0aWNfY2FzdFx1MDAzYyB2b2lkIChTZWxmOjoqKShpbnQpIFx1MDAzZShcdTAwMjZTZWxmOjpzZXRfY291bnQpKTtcbiAgICAgICAgQ09OQ0VQVF9BU1NFUlQoc3RhdGljX2Nhc3RcdTAwM2MgaW50ICgqKSgpIFx1MDAzZShcdTAwMjZTZWxmOjptYXhfY291bnQpKTtcbiAgICBDT05DRVBUX0NIRUNLX0VORFxufTtcblxuLy8gRGVmaW5lIG91ciBzdHJ1Y3RcbnN0cnVjdCBNeUNvdW50ZXIge1xuICAgIGludCBjb3VudDtcblxuICAgIGludCBnZXRfY291bnQoKSB7IHJldHVybiBjb3VudDsgfVxuICAgIHZvaWQgc2V0X2NvdW50KGludCBuZXdfY291bnQpIHsgY291bnQgPSBuZXdfY291bnQ7IH1cbiAgICBzdGF0aWMgaW50IG1heF9jb3VudCgpIHsgcmV0dXJuIDEwMDsgfVxufTtcbi8vIC4uLiBza2lwcGluZyBkZWZpbml0aW9uIG9mIHN0cnVjdCBNeUNvdW50ZXIgLi4uXG4vLyBEZWNsYXJlIGFuZCBjaGVjayB0aGF0IHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIHRyYWl0XG5JTVBMX0NPTkNFUFQoQ291bnRlciwgTXlDb3VudGVyKTtcblxuLy8gRXhhbXBsZSB1c2FnZSB1c2luZyBjbGFzc2ljIGVuYWJsZV9pZiBTRklOQUVcbnRlbXBsYXRlIFx1MDAzY3R5cGVuYW1lIFRcdTAwM2VcbnR5cGVuYW1lIHN0ZDo6ZW5hYmxlX2lmXHUwMDNjXG4gICAgQ291bnRlcjo6aXNfaW1wbGVtZW50ZWRfYnlcdTAwM2NUXHUwMDNlOjp2YWx1ZSxcbnZvaWQgXHUwMDNlOjp0eXBlXG5wcmludF9jb3VudGVyKFRcdTAwMjYgY291bnRlcikge1xuICAgIHN0ZDo6Y291dCBcdTAwM2NcdTAwM2MgXCJDb3VudGVyIHdpdGggY291bnQgXCIgXHUwMDNjXHUwMDNjIGNvdW50ZXIuZ2V0X2NvdW50KCkgXHUwMDNjXHUwMDNjIHN0ZDo6ZW5kbDtcbn1cblxuaW50IG1haW4oKSB7XG4gICAgTXlDb3VudGVyIGNvdW50ZXI7XG4gICAgY291bnRlci5jb3VudCA9IDI1O1xuICAgIENvdW50ZXI6OmNoZWNrXHUwMDNjTXlDb3VudGVyXHUwMDNlIHg7XG4gICAgcHJpbnRfY291bnRlcihjb3VudGVyKTtcbn0ifV19 target=_blank>&#9654;</a></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Define the concept
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span> {
    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_implemented_by</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>false_type {};

    <span style=color:#75715e>// Define the check
</span><span style=color:#75715e></span>    CONCEPT_CHECK_BEGIN
        <span style=color:#a6e22e>CONCEPT_ASSERT</span>(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int</span> (Self<span style=color:#f92672>::*</span>)() <span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>Self<span style=color:#f92672>::</span>get_count));
        CONCEPT_ASSERT(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> (Self<span style=color:#f92672>::*</span>)(<span style=color:#66d9ef>int</span>) <span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>Self<span style=color:#f92672>::</span>set_count));
        CONCEPT_ASSERT(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>)() <span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>Self<span style=color:#f92672>::</span>max_count));
    CONCEPT_CHECK_END
};

<span style=color:#75715e>// ... skipping definition of struct MyCounter ...
</span><span style=color:#75715e>// Declare and check that we have implemented the trait
</span><span style=color:#75715e></span>IMPL_CONCEPT(Counter, MyCounter);
</code></pre></div><p>We can now use this for defining <code>print_count</code> using the same <code>enable_if</code> way we used previously. Also most of our macros are simple ones that dont require any parenthesis-escaping except <code>IMPL_CONCEPT</code>. Note these macros are completely optional in C++11.</p><details><summary>C++03 details and the macros</summary><p><code>BOOST_STATIC_ASSERT</code> can not take reference to a function (and <code>static_assert</code> is C++11)</p><pre><code>&lt;source&gt;:67:67: error: '&amp;' cannot appear in a constant-expression
   67 |         BOOST_STATIC_ASSERT(static_cast&lt; int (Self::*)() &gt;(&amp;Self::get_count));
</code></pre><p>We get around this by defining the <code>CONCEPT_ASSERT</code> macro expands an empty function in C++03, and the <code>CONCEPT_CHECK_BEGIN</code> defines the constructor of a <code>check&lt;Self></code> struct. This object is then internal-linkage-constructed by <code>IMPL_CONCEPT</code>. This ensures that the compiler tries to specialize the constructor with <code>Self</code> and detects that the <code>static_cast</code>s failed.</p><p>Note the <code>CONCEPT_ASSERT</code> macro should not be used for &ldquo;normal&rdquo;/non-method check asserts as it simply does nothing. Use say <code>BOOST_STATIC_ASSERT</code> otherwise.</p><p>See example preprocessor output <a href=https://godbolt.org/z/vn9eKr6G1>here</a></p><p>We can check the compile time error because <code>get_count</code> is commented out</p><ul><li><a href=https://godbolt.org/z/TY5ce3G9b>Gcc 4.9</a> (<a href=https://godbolt.org/z/oca3efas4>GCC 4.1.2</a>)</li><li><a href=https://godbolt.org/z/fnndG38cc>Clang 3.4</a></li><li><a href=https://godbolt.org/z/5xvnErG1v>MSVC 19.14 (2017 - new but oldest on godbolt)</a></li><li><a href=https://godbolt.org/z/M1oT6na4v>ICC 13.0.1 (2012)</a></li></ul></details><h2 id=aside-explicit-concepts-in-c20>Aside: Explicit concepts in C++20</h2><p>Explicit concepts can be implemented in pretty much the same way in C++20, using a templated <code>is_counter</code> conditional struct</p><div class=code-play-button><a href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siY29tcGlsZXJzIjpbeyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKysyMCJ9XSwiZXhlY3V0b3JzIjpbeyJhcmd1bWVudHMiOiIiLCJjb21waWxlciI6eyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKysyMCJ9LCJjb21waWxlck91dHB1dFZpc2libGUiOiJ0cnVlIn1dLCJpZCI6MSwibGFuZ3VhZ2UiOiJjKysiLCJzb3VyY2UiOiIjaW5jbHVkZSBcdTAwM2Npb3N0cmVhbVx1MDAzZVxuI2luY2x1ZGUgXHUwMDNjY29uY2VwdHNcdTAwM2VcbiNpbmNsdWRlIFx1MDAzY3R5cGVfdHJhaXRzXHUwMDNlXG5cbi8vIEV4cGxpY2l0IGNoZWNrXG50ZW1wbGF0ZSBcdTAwM2N0eXBlbmFtZSBTZWxmXHUwMDNlXG5zdHJ1Y3QgaXNfY291bnRlcjogc3RkOjpmYWxzZV90eXBlIHt9O1xuXG4vLyBEZWZpbmUgdGhlIGNvbmNlcHQgY2hlY2tcbnRlbXBsYXRlIFx1MDAzY3R5cGVuYW1lIFNlbGZcdTAwM2VcbmNvbmNlcHQgQ291bnRlciA9XG4gICAgaXNfY291bnRlclx1MDAzY1NlbGZcdTAwM2U6OnZhbHVlIFx1MDAyNlx1MDAyNiAgICAgICAgICAgICAgIC8vICoqIE5FVyAqKlxuICAgIHJlcXVpcmVzKFNlbGYgY291bnRlciwgaW50IG5ld19jb3VudCkgeyAgLy8gKiogU0FNRSBTVFVGRiAqKlxuICAgICAgICB7IGNvdW50ZXIuZ2V0X2NvdW50KCkgfSAtXHUwMDNlIHN0ZDo6c2FtZV9hc1x1MDAzY2ludFx1MDAzZTtcbiAgICAgICAgeyBjb3VudGVyLnNldF9jb3VudChuZXdfY291bnQpIH0gLVx1MDAzZSBzdGQ6OnNhbWVfYXNcdTAwM2N2b2lkXHUwMDNlO1xuICAgICAgICB7IFNlbGY6Om1heF9jb3VudCgpIH0gLVx1MDAzZSBzdGQ6OnNhbWVfYXNcdTAwM2NpbnRcdTAwM2U7XG4gICAgfTtcblxuLy8gT3VyIHN0cnVjdFxuc3RydWN0IE15Q291bnRlciB7XG4gICAgaW50IGNvdW50O1xuXG4gICAgaW50IGdldF9jb3VudCgpIHsgcmV0dXJuIGNvdW50OyB9XG4gICAgdm9pZCBzZXRfY291bnQoaW50IG5ld19jb3VudCkgeyBjb3VudCA9IG5ld19jb3VudDsgfVxuICAgIHN0YXRpYyBpbnQgbWF4X2NvdW50KCkgeyByZXR1cm4gMTAwOyB9XG59O1xuLy8gLi4uIHNraXBwaW5nIGRlZmluaXRpb24gb2Ygc3RydWN0IE15Q291bnRlciAuLi5cbi8vIERlY2xhcmUgYW5kIGNoZWNrIHRoYXQgd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgdHJhaXRcbnRlbXBsYXRlIFx1MDAzY1x1MDAzZSBzdHJ1Y3QgaXNfY291bnRlclx1MDAzY015Q291bnRlclx1MDAzZSA6IHN0ZDo6dHJ1ZV90eXBlIHt9O1xuc3RhdGljX2Fzc2VydChDb3VudGVyXHUwMDNjTXlDb3VudGVyXHUwMDNlKTsgLy8gb3B0aW9uYWxseSBjaGVjayBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmb3Jnb3QgYW55IG1ldGhvZHMsIGV0Yy4uLlxuXG4vLyBFeGFtcGxlIHVzYWdlXG50ZW1wbGF0ZSBcdTAwM2N0eXBlbmFtZSBUXHUwMDNlXG5yZXF1aXJlcyBDb3VudGVyXHUwMDNjVFx1MDAzZVxudm9pZCBwcmludF9jb3VudGVyKFRcdTAwMjYgY291bnRlcikge1xuICAgIC8vIENhbiBhbHNvIHVzZSBzaG9ydGhhbmQgYHRlbXBsYXRlIFx1MDAzY0NvdW50ZXIgVFx1MDAzZWAgaW5zdGVhZCBvZiBgcmVxdWlyZXNgIGNsYXVzZVxuICAgIHN0ZDo6Y291dCBcdTAwM2NcdTAwM2MgXCJDb3VudGVyIHdpdGggY291bnQgXCIgXHUwMDNjXHUwMDNjIGNvdW50ZXIuZ2V0X2NvdW50KCkgXHUwMDNjXHUwMDNjIHN0ZDo6ZW5kbDtcbn1cblxuaW50IG1haW4oKSB7XG4gICAgTXlDb3VudGVyIGMgeyAyNSB9O1xuICAgIHByaW50X2NvdW50ZXIoYyk7XG59In1dfQ==" target=_blank>&#9654;</a></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Explicit check
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_counter</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>false_type {};

<span style=color:#75715e>// Define the concept check
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>concept</span> Counter <span style=color:#f92672>=</span>
    is_counter<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>&amp;&amp;</span>               <span style=color:#75715e>// ** NEW **
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>requires</span>(Self counter, <span style=color:#66d9ef>int</span> new_count) {  <span style=color:#75715e>// ** SAME STUFF **
</span><span style=color:#75715e></span>        { counter.get_count() } <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>same_as<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>;
        { counter.set_count(new_count) } <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>same_as<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>;
        { Self<span style=color:#f92672>::</span>max_count() } <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>same_as<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>;
    };

<span style=color:#75715e>// ... skipping definition of struct MyCounter ...
</span><span style=color:#75715e>// Declare and check that we have implemented the trait
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_counter</span><span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span> <span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>true_type {};
<span style=color:#66d9ef>static_assert</span>(Counter<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span>); <span style=color:#75715e>// optionally check implementation
</span><span style=color:#75715e></span>                                   <span style=color:#75715e>// if we forgot any methods, etc...
</span></code></pre></div><h2 id=rant-on-c20-concepts>Rant on C++20 Concepts</h2><p>C++20 Concepts thus allow for powerful implicit matching. But, let us take the following example:</p><blockquote><p>Lets say we are building some kind of social media stats app and we have <code>youtube_api::VideoViewCounter</code> and <code>instagram_api::LikeCounter</code>. Both of them have the <code>get_count</code> method.</p><p>We want to define a <code>print_count(counter)</code> method which takes either of these two classes and does <code>std::cout &lt;&lt; counter.get_count()</code>.</p></blockquote><p>We do not have control over either APIs, but would like a common abstraction. We can:</p><ol><li>Declare an &ldquo;implicit concept&rdquo; called <code>Counter</code> which requires a <code>get_count</code> method. Define templated <code>print_count</code> for concept</li><li>Declare an &ldquo;explicit concept&rdquo; with the same. Specify that the above two classes implement this concept without modying the classes. Define templated <code>print_count</code> for concept.</li><li>Use an unchecked templated <code>print_count</code></li></ol><p>Now consider the following modification to the codebase:</p><blockquote><p>We add class <code>my_shared_ptr</code> which has <code>get_count</code> method which returns the reference count of the pointer.</p><p>Lets say another engineer started refactoring to store the objects in <code>shared_ptr</code> but <code>print_counter</code> has not been modified for an explicit overload for <code>shared_ptr</code></p><p>What happens when we call <code>print_count(counter_ptr)</code> with <code>counter_ptr = my_shared_ptr&lt;youtube_api::VideoViewCounter>()</code>?</p></blockquote><p>Note that:</p><ol><li>In the case of &ldquo;implicit concepts&rdquo;, we would see the reference count being printed, without any compile or run-time error.</li><li>In the case of &ldquo;explicit concepts&rdquo;, we would get a compile time error since no method matches this.</li><li>In the case of an unchecked template too, we would see the reference count being printed too.</li></ol><p>Thus, <em>implicit concepts are almost as bad as not having any check at all</em>. Except maybe they can produce neater compiler errors (ignoring the case of overloading based on concepts).</p><p>Even if you had a 1000 different classes, writing 1000 more lines saying that a concept is implemented by them is better than implicit behaviour in my opinion. In most cases you will either have 1000 template specializations or some script generated code, and in both cases you only need to add one line.</p><blockquote><p>What regex is to parsing, implicit concepts are to C++.</p></blockquote><p>And if explicit concepts are better and already implementable in C++03, why provide an abstraction where most developers will write error-prone code instead of providing syntax sugar for explicit concepts?</p><h2 id=extra-syntactic-sugar-stuff>Extra syntactic sugar stuff</h2><ul><li>Using C++20 Concepts with C++03 concepts<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>concept</span> Counter_ <span style=color:#f92672>=</span> Counter<span style=color:#f92672>::</span>is_implemented_by<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>value;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_counter</span>(Counter_ <span style=color:#66d9ef>auto</span> counter) { ... }
</code></pre></div></li><li>Requiring multiple C++03 Concepts to be satisfied<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self, <span style=color:#66d9ef>typename</span>... Trait<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>require_concepts</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>conjunction<span style=color:#f92672>&lt;</span> Trait<span style=color:#f92672>::</span>is_implemented_by<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;</span>... <span style=color:#f92672>&gt;</span> {};

USE AS std<span style=color:#f92672>::</span>enable_if<span style=color:#f92672>&lt;</span>require_concepts<span style=color:#f92672>&lt;</span>Cls, Concept1, Concept2<span style=color:#f92672>&gt;&gt;</span> ...
</code></pre></div></li><li>Composing concepts - Using other concept checks in a check (slightly leaky abstraction for C++03)<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>CONCEPT_CHECK_BEGIN
  <span style=color:#75715e>// Require other_concept to be implemented
</span><span style=color:#75715e></span>  BOOST_STATIC_ASSERT(other_concept<span style=color:#f92672>::</span>is_implemented_by<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>value)
  <span style=color:#75715e>// Require either_concept1 or or_concept to be implemented
</span><span style=color:#75715e></span>  BOOST_STATIC_ASSERT(either_concept1<span style=color:#f92672>::</span>is_implemented_by<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>||</span> or_concept2<span style=color:#f92672>::</span>is_implemented_by<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>value)
CONCEPT_CHECK_END
</code></pre></div></li></ul><h2 id=summary>Summary</h2><p>We saw what C++ concepts were and how to write &ldquo;explicit concepts&rdquo; in C++03. We also noted that C++20 implicit concepts are error-prone.</p><p>In the next post I will describe how this compares to Rust traits and how to implement &ldquo;trait objects&rdquo; or &ldquo;concept maps&rdquo; using the same code.</p><p><strong>NOTE</strong>: For any of the &ldquo;predefined concepts&rdquo; like say <code>copy_constructible</code>, <code>type_traits</code> or similar Boost/utility library can be used.</p></div><div class=tags>[ Tags:
<a href=../../tags/c++>#C++</a>
<a href=../../tags/rust>#Rust</a>
<a href=../../tags/series-btrait-intro>#series-btrait-intro</a>
]
[ Crossposts:
<a href="https://news.ycombinator.com/item?id=32356522">hackernews</a>
<a href=https://www.reddit.com/r/cpp/comments/wgxjzy/c20_concepts_in_c03/>reddit</a>
]</div></article><script src=https://utteranc.es/client.js repo=meghprkh/blog issue-term=pathname label=comments theme=github-light crossorigin=anonymous async></script></main><footer><p>&copy; 2022 <a href=http://meghprkh.github.io/blog/>Megh's Blog</a></p></footer><script src=../../js/theme.js></script></body></html>