<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>C++20 Concepts in C++03</title><link rel=stylesheet href=../../css/style.css></head><body><header class=site-header><h1>Megh's Blog</h1><nav><ul><li><a href=../../>Home</a></li><li><a href=../../categories>Categories</a></li><li><a href=../../tags>Tags</a></li><li><a href=../../about>About</a></li><li><a href=../../index.xml>Feed</a></li></ul></nav></header><main><article class=post><h1 class=title>C++20 Concepts in C++03</h1><div class=article-details><time>Thu Aug 4 2022</time>
in
<a href=../../categories/c++>C++</a></div><div><nav id=TableOfContents><ul><li><a href=#what-are-c-concepts>What are C++ Concepts</a></li><li><a href=#c03-concepts>C++03 Concepts</a></li><li><a href=#aside-explicit-concepts-in-c20>Aside: Explicit concepts in C++20</a></li><li><a href=#rant-on-c20-concepts>Rant on C++20 Concepts</a></li><li><a href=#extra-syntactic-sugar-stuff>Extra syntactic sugar stuff</a></li><li><a href=#summary>Summary</a></li></ul></nav><p>C++20 Concepts are a new language feature that ease generic programming, but are primarily syntactic sugar.</p><p>We will try to implement them in C++03, with one caveat - we must <em>explicitly specify that a class implements an concept</em>.</p><p><strong>NOTE</strong>: We will use template specialization and do not need to be able to modify the class or our concept for this.</p><h2 id=what-are-c-concepts>What are C++ Concepts</h2><p>C++ Concepts allow us to do compile-time dispatch of methods. Kind of like Rust traits.</p><div class=code-play-button><a href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siY29tcGlsZXJzIjpbeyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKysyMCJ9XSwiZXhlY3V0b3JzIjpbeyJjb21waWxlciI6eyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKysyMCJ9fV0sImlkIjoxLCJsYW5ndWFnZSI6ImMrKyIsInNvdXJjZSI6IiNpbmNsdWRlIFx1MDAzY2lvc3RyZWFtXHUwMDNlXG4jaW5jbHVkZSBcdTAwM2Njb25jZXB0c1x1MDAzZVxuXG4vLyBEZWZpbmUgdGhlIGNvbmNlcHQgY2hlY2tcbnRlbXBsYXRlIFx1MDAzY3R5cGVuYW1lIFNlbGZcdTAwM2VcbmNvbmNlcHQgQ291bnRlciA9IHJlcXVpcmVzKFNlbGYgY291bnRlciwgaW50IG5ld19jb3VudCkge1xuICAgIHsgY291bnRlci5nZXRfY291bnQoKSB9IC1cdTAwM2Ugc3RkOjpzYW1lX2FzXHUwMDNjaW50XHUwMDNlO1xuICAgIHsgY291bnRlci5zZXRfY291bnQobmV3X2NvdW50KSB9IC1cdTAwM2Ugc3RkOjpzYW1lX2FzXHUwMDNjdm9pZFx1MDAzZTtcbiAgICB7IFNlbGY6Om1heF9jb3VudCgpIH0gLVx1MDAzZSBzdGQ6OnNhbWVfYXNcdTAwM2NpbnRcdTAwM2U7XG59O1xuXG4vLyBPdXIgc3RydWN0XG5zdHJ1Y3QgTXlDb3VudGVyIHtcbiAgICBpbnQgY291bnQ7XG5cbiAgICBpbnQgZ2V0X2NvdW50KCkgeyByZXR1cm4gY291bnQ7IH1cbiAgICB2b2lkIHNldF9jb3VudChpbnQgbmV3X2NvdW50KSB7IGNvdW50ID0gbmV3X2NvdW50OyB9XG4gICAgc3RhdGljIGludCBtYXhfY291bnQoKSB7IHJldHVybiAxMDA7IH1cbn07XG5cbi8vIEV4YW1wbGUgdXNhZ2VcbnRlbXBsYXRlIFx1MDAzY3R5cGVuYW1lIFRcdTAwM2VcbnJlcXVpcmVzIENvdW50ZXJcdTAwM2NUXHUwMDNlXG52b2lkIHByaW50X2NvdW50ZXIoVFx1MDAyNiBjb3VudGVyKSB7XG4gICAgLy8gQ2FuIGFsc28gdXNlIHNob3J0aGFuZCBgdGVtcGxhdGUgXHUwMDNjQ291bnRlciBUXHUwMDNlYCBpbnN0ZWFkIG9mIGByZXF1aXJlc2AgY2xhdXNlXG4gICAgc3RkOjpjb3V0IFx1MDAzY1x1MDAzYyBcIkNvdW50ZXIgd2l0aCBjb3VudCBcIiBcdTAwM2NcdTAwM2MgY291bnRlci5nZXRfY291bnQoKSBcdTAwM2NcdTAwM2Mgc3RkOjplbmRsO1xufVxuXG4vLyBTaG9ydGhhbmQgc3ludGF4XG52b2lkIHByaW50X2NvdW50ZXJfc2hvcnRoYW5kKENvdW50ZXIgYXV0byBjb3VudGVyKSB7IHByaW50X2NvdW50ZXIoY291bnRlcik7IH1cblxuaW50IG1haW4oKSB7XG4gICAgTXlDb3VudGVyIGMgeyAyNSB9O1xuICAgIHByaW50X2NvdW50ZXIoYyk7XG4gICAgcHJpbnRfY291bnRlcl9zaG9ydGhhbmQoYyk7XG59In1dfQ==" target=_blank>&#9654;</a></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Define the concept check
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>concept</span> Counter <span style=color:#f92672>=</span> <span style=color:#66d9ef>requires</span>(Self counter, <span style=color:#66d9ef>int</span> new_count) {
    { counter.get_count() } <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>same_as<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>;
    { counter.set_count(new_count) } <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>same_as<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>;
    { Self<span style=color:#f92672>::</span>max_count() } <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>same_as<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>;
};

<span style=color:#75715e>// Our struct
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyCounter</span> {
    <span style=color:#66d9ef>int</span> count;

    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get_count</span>() { <span style=color:#66d9ef>return</span> count; }
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_count</span>(<span style=color:#66d9ef>int</span> new_count) { count <span style=color:#f92672>=</span> new_count; }
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max_count</span>() { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>100</span>; }
};

<span style=color:#75715e>// Example usage
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>requires</span> Counter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>void</span> print_counter(T<span style=color:#f92672>&amp;</span> counter) {
    <span style=color:#75715e>// Can also use shorthand `template &lt;Counter T&gt;` instead of `requires` clause
</span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Counter with count &#34;</span> <span style=color:#f92672>&lt;&lt;</span> counter.get_count() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
}

<span style=color:#75715e>// Shorthand syntax
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_counter_shorthand</span>(Counter <span style=color:#66d9ef>auto</span> counter) { print_counter(counter); }

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    MyCounter c { <span style=color:#ae81ff>25</span> };
    print_counter(c);
    print_counter_shorthand(c);
}
</code></pre></div><p>Notice that we never needed to specify that <code>MyCounter</code> implements <code>Counter</code>. This can easily be fixed by requiring some constant to be defined in <code>MyCounter</code> or otherwise.</p><p>We call the above <strong>&ldquo;implicit concepts&rdquo;</strong>. We will try to implement <strong>&ldquo;explicit concepts&rdquo;</strong> - where something must specify that the concept has been implemented for a class.</p><h2 id=c03-concepts>C++03 Concepts</h2><p>We will use C++11 initially. Then will also modify this using some macros for C++03.</p><p>We use a templated struct and observe that <code>static_asserts</code> inside it are executed when the template is specialized.</p><div class=code-play-button><a href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siY29tcGlsZXJzIjpbeyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKysxMSJ9XSwiZXhlY3V0b3JzIjpbeyJjb21waWxlciI6eyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKysxMSJ9fV0sImlkIjoxLCJsYW5ndWFnZSI6ImMrKyIsInNvdXJjZSI6IiNpbmNsdWRlIFx1MDAzY2lvc3RyZWFtXHUwMDNlXG4jaW5jbHVkZSBcdTAwM2N0eXBlX3RyYWl0c1x1MDAzZVxuXG4vLyBEZWZpbmUgdGhlIGNvbmNlcHRcbnN0cnVjdCBDb3VudGVyIHtcbiAgICAvLyBUaGlzIHRlbXBsYXRlIGlzIHNwZWNpYWxpemVkIHRvIHRydWVfdHlwZSBieSBhbnkgY2xhc3MgdGhhdFxuICAgIC8vIGltcGxlbWVudHMgdGhpcy4gU3BlY2lhbGl6YXRpb24gcmVxdWlyZXMgb3duZXJzaGlwIG9mIG5laXRoZXJcbiAgICAvLyBDb3VudGVyIGNvbmNlcHQgb3IgU2VsZiAoU2VsZiBiZWluZyB0aGUgY2xhc3MgaW4gcXVlc3Rpb24pXG4gICAgdGVtcGxhdGUgXHUwMDNjdHlwZW5hbWUgU2VsZlx1MDAzZVxuICAgIHN0cnVjdCBpc19pbXBsZW1lbnRlZF9ieTogc3RkOjpmYWxzZV90eXBlIHt9O1xuXG4gICAgLy8gRGVmaW5lIHRoZSBjaGVja1xuICAgIHRlbXBsYXRlIFx1MDAzY3R5cGVuYW1lIFNlbGZcdTAwM2VcbiAgICBzdHJ1Y3QgY2hlY2s6IHN0ZDo6dHJ1ZV90eXBlIHtcbiAgICAgICAgc3RhdGljX2Fzc2VydChzdGF0aWNfY2FzdFx1MDAzYyBpbnQgKFNlbGY6OiopKCkgXHUwMDNlKFx1MDAyNlNlbGY6OmdldF9jb3VudCkpO1xuICAgICAgICBzdGF0aWNfYXNzZXJ0KHN0YXRpY19jYXN0XHUwMDNjIHZvaWQgKFNlbGY6OiopKGludCkgXHUwMDNlKFx1MDAyNlNlbGY6OnNldF9jb3VudCkpO1xuICAgICAgICBzdGF0aWNfYXNzZXJ0KHN0YXRpY19jYXN0XHUwMDNjIGludCAoKikoKSBcdTAwM2UoXHUwMDI2U2VsZjo6bWF4X2NvdW50KSk7XG4gICAgfTtcbn07XG5cbi8vIERlZmluZSBvdXIgc3RydWN0IG5vcm1hbGx5LCB3aXRob3V0IGFueSBtb2RpZmljYXRpb25zXG5zdHJ1Y3QgTXlDb3VudGVyIHtcbiAgICBpbnQgY291bnQ7XG5cbiAgICBpbnQgZ2V0X2NvdW50KCkgeyByZXR1cm4gY291bnQ7IH1cbiAgICB2b2lkIHNldF9jb3VudChpbnQgbmV3X2NvdW50KSB7IGNvdW50ID0gbmV3X2NvdW50OyB9XG4gICAgc3RhdGljIGludCBtYXhfY291bnQoKSB7IHJldHVybiAxMDA7IH1cbn07XG4vLyBEZWNsYXJlIGFuZCBjaGVjayB0aGF0IHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIHRyYWl0XG50ZW1wbGF0ZVx1MDAzY1x1MDAzZVxuc3RydWN0IENvdW50ZXI6OmlzX2ltcGxlbWVudGVkX2J5XHUwMDNjTXlDb3VudGVyXHUwMDNlOiBDb3VudGVyOjpjaGVja1x1MDAzY015Q291bnRlclx1MDAzZSB7fTtcblxuLy8gRXhhbXBsZSB1c2FnZSB1c2luZyBjbGFzc2ljIGVuYWJsZV9pZiBTRklOQUUuIFZlcmJvc2UgeWV0IGNvbnZlbnRpb25hbFxudGVtcGxhdGUgXHUwMDNjdHlwZW5hbWUgVFx1MDAzZVxudHlwZW5hbWUgc3RkOjplbmFibGVfaWZcdTAwM2NcbiAgICBDb3VudGVyOjppc19pbXBsZW1lbnRlZF9ieVx1MDAzY1RcdTAwM2U6OnZhbHVlLFxudm9pZCBcdTAwM2U6OnR5cGVcbnByaW50X2NvdW50ZXIoVFx1MDAyNiBjb3VudGVyKSB7XG4gICAgc3RkOjpjb3V0IFx1MDAzY1x1MDAzYyBcIkNvdW50ZXIgd2l0aCBjb3VudCBcIiBcdTAwM2NcdTAwM2MgY291bnRlci5nZXRfY291bnQoKSBcdTAwM2NcdTAwM2Mgc3RkOjplbmRsO1xufVxuXG5pbnQgbWFpbigpIHtcbiAgICBNeUNvdW50ZXIgY291bnRlciB7IDMgfTtcbiAgICBwcmludF9jb3VudGVyKGNvdW50ZXIpO1xufSJ9XX0=" target=_blank>&#9654;</a></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Define the concept
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span> {
    <span style=color:#75715e>// This template is specialized to true_type by any class that
</span><span style=color:#75715e></span>    <span style=color:#75715e>// implements this. Specialization requires ownership of neither
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Counter concept or Self (Self being the class in question)
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_implemented_by</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>false_type {};

    <span style=color:#75715e>// Define the check
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>check</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>true_type {
        <span style=color:#66d9ef>static_assert</span>(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int</span> (Self<span style=color:#f92672>::*</span>)() <span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>Self<span style=color:#f92672>::</span>get_count));
        <span style=color:#66d9ef>static_assert</span>(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> (Self<span style=color:#f92672>::*</span>)(<span style=color:#66d9ef>int</span>) <span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>Self<span style=color:#f92672>::</span>set_count));
        <span style=color:#66d9ef>static_assert</span>(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>)() <span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>Self<span style=color:#f92672>::</span>max_count));
    };
};

<span style=color:#75715e>// Define our struct normally, without any modifications
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyCounter</span> {
    <span style=color:#66d9ef>int</span> count;

    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>get_count</span>() { <span style=color:#66d9ef>return</span> count; }
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_count</span>(<span style=color:#66d9ef>int</span> new_count) { count <span style=color:#f92672>=</span> new_count; }
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>max_count</span>() { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>100</span>; }
};
<span style=color:#75715e>// Declare and check that we have implemented the trait
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span><span style=color:#f92672>::</span>is_implemented_by<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;:</span> Counter<span style=color:#f92672>::</span>check<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span> {};

<span style=color:#75715e>// Example usage using classic enable_if SFINAE. Verbose yet conventional
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>typename</span> std<span style=color:#f92672>::</span>enable_if<span style=color:#f92672>&lt;</span>
    Counter<span style=color:#f92672>::</span>is_implemented_by<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>value,
<span style=color:#66d9ef>void</span> <span style=color:#f92672>&gt;::</span>type
print_counter(T<span style=color:#f92672>&amp;</span> counter) {
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Counter with count &#34;</span> <span style=color:#f92672>&lt;&lt;</span> counter.get_count() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    MyCounter counter { <span style=color:#ae81ff>3</span> };
    print_counter(counter);
}
</code></pre></div><p>To do this in C++03, lets sprinkle some macros. We will also <em>beautify</em> the C++11 code using macros.</p><div class=code-play-button><a href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siY29tcGlsZXJzIjpbeyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKyswMyJ9XSwiZXhlY3V0b3JzIjpbeyJjb21waWxlciI6eyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKyswMyJ9fV0sImlkIjoxLCJsYW5ndWFnZSI6ImMrKyIsInNvdXJjZSI6IiNpbmNsdWRlIFx1MDAzY2lvc3RyZWFtXHUwMDNlXG5cbiNpZiBfX2NwbHVzcGx1cyAhPSAxOTk3MTFMXG4jaW5jbHVkZSBcdTAwM2N0eXBlX3RyYWl0c1x1MDAzZVxuI2Vsc2Vcbi8vIE1vbmtleSBwYXRjaCBzdGQgZm9yIHRoZSBzYWtlIG9mIHRoZSBleGFtcGxlXG4vLyBDYW4gdXNlIHlvdXIgZmF2b3VyaXRlIHV0aWxpdHkgbGlicmFyeSBpbnN0ZWFkXG5uYW1lc3BhY2Ugc3RkIHtcbiAgICBzdHJ1Y3QgdHJ1ZV90eXBlIHsgc3RhdGljIGNvbnN0IGJvb2wgdmFsdWUgPSB0cnVlOyB9O1xuICAgIHN0cnVjdCBmYWxzZV90eXBlIHsgc3RhdGljIGNvbnN0IGJvb2wgdmFsdWUgPSB0cnVlOyB9O1xuICAgIHRlbXBsYXRlIFx1MDAzY2Jvb2wgQ29uZCwgdHlwZW5hbWUgVHlwZSA9IHZvaWRcdTAwM2VcbiAgICBzdHJ1Y3QgZW5hYmxlX2lmIHsgdHlwZWRlZiBUeXBlIHR5cGU7IH07XG4gICAgdGVtcGxhdGUgXHUwMDNjdHlwZW5hbWUgVHlwZVx1MDAzZVxuICAgIHN0cnVjdCBlbmFibGVfaWZcdTAwM2NmYWxzZSwgVHlwZVx1MDAzZSB7IH07XG59XG4jZW5kaWZcblxuI2RlZmluZSBfQ09OQ0VQVF9UT0tFTlBBU1RFKHgsIHkpIHggIyMgeVxuI2RlZmluZSBfQ09OQ0VQVF9UT0tFTlBBU1RFMih4LCB5KSBfQ09OQ0VQVF9UT0tFTlBBU1RFKHgsIHkpXG5cbiNpZiBfX2NwbHVzcGx1cyAhPSAxOTk3MTFMXG5cbiNkZWZpbmUgQ09OQ0VQVF9DSEVDS19TVEFSVCBcXFxuICAgIHRlbXBsYXRlIFx1MDAzY3R5cGVuYW1lIFNlbGZcdTAwM2UgXFxcbiAgICBzdHJ1Y3QgY2hlY2s6IHN0ZDo6dHJ1ZV90eXBlIHsgXFxcblxuI2RlZmluZSBDT05DRVBUX0NIRUNLX0VORCB9O1xuXG4jZGVmaW5lIENPTkNFUFRfQVNTRVJUIHN0YXRpY19hc3NlcnRcblxuI2RlZmluZSBJTVBMX0NPTkNFUFQoQ09OQ0VQVCwgQ0xTKSBcXFxuICAgIHRlbXBsYXRlXHUwMDNjXHUwMDNlIFxcXG4gICAgc3RydWN0IENPTkNFUFQ6OmlzX2ltcGxlbWVudGVkX2J5XHUwMDNjQ0xTXHUwMDNlOiBDT05DRVBUOjpjaGVja1x1MDAzY0NMU1x1MDAzZSB7fTsgXFxcblxuI2Vsc2VcblxuLy8gSW4gQysrMDMgd2UgZG9udCBoYXZlIHN0YXRpY19hc3NlcnQgYW5kIHdlIGNhbm5vdCB1c2UgXCJcdTAwMjZUOjptZXRob2RcIlxuLy8gaW5zaWRlIHNheSBhIEJPT1NUX1NUQVRJQ19BU1NFUlQuXG4vLyBXZSBqdXN0IGRlZmluZSBhbGwgb2YgdGhlIGNoZWNrcyBpbnNpZGUgdGhlIGNvbnN0cnVjdG9yIG9mIGBjaGVja2AuXG4vLyBUaGVuIGluIGBJTVBMX0NPTkNFUFRgIHdlIGluc3RhbnRpYXRlIGEgc3RhdGljIG9iamVjdCBvZiB0aGUgc2FtZS5cblxuI2RlZmluZSBDT05DRVBUX0NIRUNLX1NUQVJUIFxcXG4gICAgdGVtcGxhdGUgXHUwMDNjdHlwZW5hbWUgU2VsZlx1MDAzZSBcXFxuICAgIHN0cnVjdCBjaGVjazogc3RkOjp0cnVlX3R5cGUgeyBcXFxuICAgICAgICBjaGVjaygpIHsgXFxcblxuI2RlZmluZSBDT05DRVBUX0NIRUNLX0VORCB9IH07XG5cbiNkZWZpbmUgQ09OQ0VQVF9BU1NFUlRcblxuI2RlZmluZSBJTVBMX0NPTkNFUFQoQ09OQ0VQVCwgQ0xTKSBcXFxuICAgIHRlbXBsYXRlXHUwMDNjXHUwMDNlIFxcXG4gICAgc3RydWN0IENPTkNFUFQ6OmlzX2ltcGxlbWVudGVkX2J5XHUwMDNjQ0xTXHUwMDNlOiBDT05DRVBUOjpjaGVja1x1MDAzY0NMU1x1MDAzZSB7fTsgXFxcbiAgICBzdGF0aWMgQ09OQ0VQVDo6Y2hlY2tcdTAwM2NDTFNcdTAwM2UgX0NPTkNFUFRfVE9LRU5QQVNURTIoX2NvbmNlcHRfY2hlY2tfLCBfX0xJTkVfXyk7IFxcXG5cbiNlbmRpZlxuXG4vLyBEZWZpbmUgdGhlIGNvbmNlcHRcbnN0cnVjdCBDb3VudGVyIHtcbiAgICB0ZW1wbGF0ZSBcdTAwM2N0eXBlbmFtZSBUXHUwMDNlXG4gICAgc3RydWN0IGlzX2ltcGxlbWVudGVkX2J5OiBzdGQ6OmZhbHNlX3R5cGUge307XG5cbiAgICAvLyBEZWZpbmUgdGhlIGNoZWNrXG4gICAgQ09OQ0VQVF9DSEVDS19TVEFSVFxuICAgICAgICBDT05DRVBUX0FTU0VSVChzdGF0aWNfY2FzdFx1MDAzYyBpbnQgKFNlbGY6OiopKCkgXHUwMDNlKFx1MDAyNlNlbGY6OmdldF9jb3VudCkpO1xuICAgICAgICBDT05DRVBUX0FTU0VSVChzdGF0aWNfY2FzdFx1MDAzYyB2b2lkIChTZWxmOjoqKShpbnQpIFx1MDAzZShcdTAwMjZTZWxmOjpzZXRfY291bnQpKTtcbiAgICAgICAgQ09OQ0VQVF9BU1NFUlQoc3RhdGljX2Nhc3RcdTAwM2MgaW50ICgqKSgpIFx1MDAzZShcdTAwMjZTZWxmOjptYXhfY291bnQpKTtcbiAgICBDT05DRVBUX0NIRUNLX0VORFxufTtcblxuLy8gRGVmaW5lIG91ciBzdHJ1Y3RcbnN0cnVjdCBNeUNvdW50ZXIge1xuICAgIGludCBjb3VudDtcblxuICAgIGludCBnZXRfY291bnQoKSB7IHJldHVybiBjb3VudDsgfVxuICAgIHZvaWQgc2V0X2NvdW50KGludCBuZXdfY291bnQpIHsgY291bnQgPSBuZXdfY291bnQ7IH1cbiAgICBzdGF0aWMgaW50IG1heF9jb3VudCgpIHsgcmV0dXJuIDEwMDsgfVxufTtcbi8vIC4uLiBza2lwcGluZyBkZWZpbml0aW9uIG9mIHN0cnVjdCBNeUNvdW50ZXIgLi4uXG4vLyBEZWNsYXJlIGFuZCBjaGVjayB0aGF0IHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIHRyYWl0XG5JTVBMX0NPTkNFUFQoQ291bnRlciwgTXlDb3VudGVyKTtcblxuLy8gRXhhbXBsZSB1c2FnZSB1c2luZyBjbGFzc2ljIGVuYWJsZV9pZiBTRklOQUVcbnRlbXBsYXRlIFx1MDAzY3R5cGVuYW1lIFRcdTAwM2VcbnR5cGVuYW1lIHN0ZDo6ZW5hYmxlX2lmXHUwMDNjXG4gICAgQ291bnRlcjo6aXNfaW1wbGVtZW50ZWRfYnlcdTAwM2NUXHUwMDNlOjp2YWx1ZSxcbnZvaWQgXHUwMDNlOjp0eXBlXG5wcmludF9jb3VudGVyKFRcdTAwMjYgY291bnRlcikge1xuICAgIHN0ZDo6Y291dCBcdTAwM2NcdTAwM2MgXCJDb3VudGVyIHdpdGggY291bnQgXCIgXHUwMDNjXHUwMDNjIGNvdW50ZXIuZ2V0X2NvdW50KCkgXHUwMDNjXHUwMDNjIHN0ZDo6ZW5kbDtcbn1cblxuaW50IG1haW4oKSB7XG4gICAgTXlDb3VudGVyIGNvdW50ZXI7XG4gICAgY291bnRlci5jb3VudCA9IDM7XG4gICAgQ291bnRlcjo6Y2hlY2tcdTAwM2NNeUNvdW50ZXJcdTAwM2UgeDtcbiAgICBwcmludF9jb3VudGVyKGNvdW50ZXIpO1xufSJ9XX0=" target=_blank>&#9654;</a></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Define the concept
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span> {
    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_implemented_by</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>false_type {};

    <span style=color:#75715e>// Define the check
</span><span style=color:#75715e></span>    CONCEPT_CHECK_START
        <span style=color:#a6e22e>CONCEPT_ASSERT</span>(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int</span> (Self<span style=color:#f92672>::*</span>)() <span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>Self<span style=color:#f92672>::</span>get_count));
        CONCEPT_ASSERT(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>void</span> (Self<span style=color:#f92672>::*</span>)(<span style=color:#66d9ef>int</span>) <span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>Self<span style=color:#f92672>::</span>set_count));
        CONCEPT_ASSERT(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>)() <span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>Self<span style=color:#f92672>::</span>max_count));
    CONCEPT_CHECK_END
};

<span style=color:#75715e>// ... skipping definition of struct MyCounter ...
</span><span style=color:#75715e>// Declare and check that we have implemented the trait
</span><span style=color:#75715e></span>IMPL_CONCEPT(Counter, MyCounter);
</code></pre></div><p>We can now use this for defining <code>print_count</code> using the same <code>enable_if</code> way we used previously. Also most of our macros are simple ones that dont require any parenthesis-escaping except <code>IMPL_CONCEPT</code>.</p><h2 id=aside-explicit-concepts-in-c20>Aside: Explicit concepts in C++20</h2><p>Explicit concepts can be implemented in pretty much the same way in C++20, using a templated <code>is_counter</code> conditional struct</p><div class=code-play-button><a href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siY29tcGlsZXJzIjpbeyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKysyMCJ9XSwiZXhlY3V0b3JzIjpbeyJjb21waWxlciI6eyJpZCI6ImcxMjEiLCJvcHRpb25zIjoiLXN0ZD1jKysyMCJ9fV0sImlkIjoxLCJsYW5ndWFnZSI6ImMrKyIsInNvdXJjZSI6IiNpbmNsdWRlIFx1MDAzY2lvc3RyZWFtXHUwMDNlXG4jaW5jbHVkZSBcdTAwM2Njb25jZXB0c1x1MDAzZVxuI2luY2x1ZGUgXHUwMDNjdHlwZV90cmFpdHNcdTAwM2VcblxuLy8gRXhwbGljaXQgY2hlY2tcbnRlbXBsYXRlIFx1MDAzY3R5cGVuYW1lIFNlbGZcdTAwM2VcbnN0cnVjdCBpc19jb3VudGVyOiBzdGQ6OmZhbHNlX3R5cGUge307XG5cbi8vIERlZmluZSB0aGUgY29uY2VwdCBjaGVja1xudGVtcGxhdGUgXHUwMDNjdHlwZW5hbWUgU2VsZlx1MDAzZVxuY29uY2VwdCBDb3VudGVyID1cbiAgICBpc19jb3VudGVyXHUwMDNjU2VsZlx1MDAzZTo6dmFsdWUgXHUwMDI2XHUwMDI2ICAgICAgICAgICAgICAgLy8gKiogTkVXICoqXG4gICAgcmVxdWlyZXMoU2VsZiBjb3VudGVyLCBpbnQgbmV3X2NvdW50KSB7ICAvLyAqKiBTQU1FIFNUVUZGICoqXG4gICAgICAgIHsgY291bnRlci5nZXRfY291bnQoKSB9IC1cdTAwM2Ugc3RkOjpzYW1lX2FzXHUwMDNjaW50XHUwMDNlO1xuICAgICAgICB7IGNvdW50ZXIuc2V0X2NvdW50KG5ld19jb3VudCkgfSAtXHUwMDNlIHN0ZDo6c2FtZV9hc1x1MDAzY3ZvaWRcdTAwM2U7XG4gICAgICAgIHsgU2VsZjo6bWF4X2NvdW50KCkgfSAtXHUwMDNlIHN0ZDo6c2FtZV9hc1x1MDAzY2ludFx1MDAzZTtcbiAgICB9O1xuXG4vLyBPdXIgc3RydWN0XG5zdHJ1Y3QgTXlDb3VudGVyIHtcbiAgICBpbnQgY291bnQ7XG5cbiAgICBpbnQgZ2V0X2NvdW50KCkgeyByZXR1cm4gY291bnQ7IH1cbiAgICB2b2lkIHNldF9jb3VudChpbnQgbmV3X2NvdW50KSB7IGNvdW50ID0gbmV3X2NvdW50OyB9XG4gICAgc3RhdGljIGludCBtYXhfY291bnQoKSB7IHJldHVybiAxMDA7IH1cbn07XG4vLyAuLi4gc2tpcHBpbmcgZGVmaW5pdGlvbiBvZiBzdHJ1Y3QgTXlDb3VudGVyIC4uLlxuLy8gRGVjbGFyZSBhbmQgY2hlY2sgdGhhdCB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSB0cmFpdFxudGVtcGxhdGUgXHUwMDNjXHUwMDNlIHN0cnVjdCBpc19jb3VudGVyXHUwMDNjTXlDb3VudGVyXHUwMDNlIDogc3RkOjp0cnVlX3R5cGUge307XG5zdGF0aWNfYXNzZXJ0KENvdW50ZXJcdTAwM2NNeUNvdW50ZXJcdTAwM2UpOyAvLyBjaGVjayBpbXBsZW1lbnRhdGlvblxuXG4vLyBFeGFtcGxlIHVzYWdlXG50ZW1wbGF0ZSBcdTAwM2N0eXBlbmFtZSBUXHUwMDNlXG5yZXF1aXJlcyBDb3VudGVyXHUwMDNjVFx1MDAzZVxudm9pZCBwcmludF9jb3VudGVyKFRcdTAwMjYgY291bnRlcikge1xuICAgIC8vIENhbiBhbHNvIHVzZSBzaG9ydGhhbmQgYHRlbXBsYXRlIFx1MDAzY0NvdW50ZXIgVFx1MDAzZWAgaW5zdGVhZCBvZiBgcmVxdWlyZXNgIGNsYXVzZVxuICAgIHN0ZDo6Y291dCBcdTAwM2NcdTAwM2MgXCJDb3VudGVyIHdpdGggY291bnQgXCIgXHUwMDNjXHUwMDNjIGNvdW50ZXIuZ2V0X2NvdW50KCkgXHUwMDNjXHUwMDNjIHN0ZDo6ZW5kbDtcbn1cblxuaW50IG1haW4oKSB7XG4gICAgTXlDb3VudGVyIGMgeyAyNSB9O1xuICAgIHByaW50X2NvdW50ZXIoYyk7XG59In1dfQ==" target=_blank>&#9654;</a></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#75715e>// Explicit check
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_counter</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>false_type {};

<span style=color:#75715e>// Define the concept check
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>concept</span> Counter <span style=color:#f92672>=</span>
    is_counter<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>&amp;&amp;</span>               <span style=color:#75715e>// ** NEW **
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>requires</span>(Self counter, <span style=color:#66d9ef>int</span> new_count) {  <span style=color:#75715e>// ** SAME STUFF **
</span><span style=color:#75715e></span>        { counter.get_count() } <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>same_as<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>;
        { counter.set_count(new_count) } <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>same_as<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>;
        { Self<span style=color:#f92672>::</span>max_count() } <span style=color:#f92672>-&gt;</span> std<span style=color:#f92672>::</span>same_as<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>;
    };

<span style=color:#75715e>// ... skipping definition of struct MyCounter ...
</span><span style=color:#75715e>// Declare and check that we have implemented the trait
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_counter</span><span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span> <span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>true_type {};
<span style=color:#66d9ef>static_assert</span>(Counter<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span>); <span style=color:#75715e>// check implementation
</span></code></pre></div><h2 id=rant-on-c20-concepts>Rant on C++20 Concepts</h2><p>C++20 Concepts thus allow for powerful implicit matching. But, let us take the following example:</p><blockquote><p>Lets say we are building some kind of social media stats app and we have <code>youtube_api::VideoViewCounter</code> and <code>instagram_api::LikeCounter</code>. Both of them have the <code>get_count</code> method.</p><p>We want to define a <code>print_count(counter)</code> method which takes either of these two classes and does <code>std::cout &lt;&lt; counter.get_count()</code>.</p></blockquote><p>We do not have control over either APIs, but would like a common abstraction. We can:</p><ol><li>Declare an &ldquo;implicit concept&rdquo; called <code>Counter</code> which requires a <code>get_count</code> method. Define templated <code>print_count</code> for concept</li><li>Declare an &ldquo;explicit concept&rdquo; with the same. Specify that the above two classes implement this concept without modying the classes. Define templated <code>print_count</code> for concept.</li><li>Use an unchecked templated <code>print_count</code></li></ol><p>Now consider the following modification to the codebase:</p><blockquote><p>We add class <code>my_shared_ptr</code> which has <code>get_count</code> method which returns the reference count of the pointer.</p><p>Lets say another engineer started refactoring to store the objects in <code>shared_ptr</code> but <code>print_counter</code> has not been modified for an explicit overload for <code>shared_ptr</code></p><p>What happens when we call <code>print_count(counter_ptr)</code> with <code>counter_ptr = my_shared_ptr&lt;youtube_api::VideoViewCounter>()</code>?</p></blockquote><p>Note that:</p><ol><li>In the case of &ldquo;implicit concepts&rdquo;, we would see the reference count being printed, without any compile or run-time error.</li><li>In the case of &ldquo;explicit concepts&rdquo;, we would get a compile time error since no method matches this.</li><li>In the case of an unchecked template too, we would see the reference count being printed too.</li></ol><p>Thus, <em>implicit concepts are almost as bad as not having any check at all</em>. Except maybe they can produce neater compiler errors (ignoring the case of overloading based on concepts).</p><blockquote><p>What regex is to parsing, implicit concepts are to C++.</p></blockquote><p>And if explicit concepts are better and already implementable in C++03, why provide an abstraction where most developers will write error-prone code instead of providing syntax sugar for explicit concepts?</p><h2 id=extra-syntactic-sugar-stuff>Extra syntactic sugar stuff</h2><ul><li>Using C++20 Concepts with C++03 concepts<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>concept</span> Counter_ <span style=color:#f92672>=</span> Counter<span style=color:#f92672>::</span>is_implemented_by<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>value;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_counter</span>(Counter_ <span style=color:#66d9ef>auto</span> counter) { ... }
</code></pre></div></li><li>Requiring multiple C++03 Concepts to be satisfied<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self, <span style=color:#66d9ef>typename</span>... Trait<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>require_concepts</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>conjunction<span style=color:#f92672>&lt;</span> Trait<span style=color:#f92672>::</span>is_implemented_by<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;</span>... <span style=color:#f92672>&gt;</span> {};

USE AS std<span style=color:#f92672>::</span>enable_if<span style=color:#f92672>&lt;</span>require_concepts<span style=color:#f92672>&lt;</span>Cls, Concept1, Concept2<span style=color:#f92672>&gt;&gt;</span> ...
</code></pre></div></li></ul><h2 id=summary>Summary</h2><p>We saw what C++ concepts were and how to write &ldquo;explicit concepts&rdquo; in C++03. We also noted that C++20 implicit concepts are error-prone.</p><p>In the next post I will describe how this compares to Rust traits and how to implement &ldquo;trait objects&rdquo; or &ldquo;concept maps&rdquo; using the same code.</p><p><strong>NOTE</strong>: For any of the &ldquo;predefined concepts&rdquo; like say <code>copy_constructible</code>, <code>type_traits</code> or similar Boost/utility library can be used.</p></div><div class=tags>[ Tags:
<a href=../../tags/c++>#C++</a>
<a href=../../tags/rust>#Rust</a>
<a href=../../tags/series-btrait-intro>#series-btrait-intro</a>
]
[ Crossposts:
<a href="https://news.ycombinator.com/item?id=32356522">hackernews</a>
<a href=https://www.reddit.com/r/cpp/comments/wgxjzy/c20_concepts_in_c03/>reddit</a>
]</div></article><script src=https://utteranc.es/client.js repo=meghprkh/blog issue-term=pathname label=comments theme=github-light crossorigin=anonymous async></script></main><footer><p>&copy; 2022 <a href=http://meghprkh.github.io/blog/>Megh's Blog</a></p></footer><script src=../../js/theme.js></script></body></html>