<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>BTrait - Combining Traits</title><link rel=stylesheet href=../../css/style.css></head><body><header class=site-header><h1>Megh's Blog</h1><nav><ul><li><a href=../../>Home</a></li><li><a href=../../categories>Categories</a></li><li><a href=../../tags>Tags</a></li><li><a href=../../about>About</a></li><li><a href=../../index.xml>Feed</a></li></ul></nav></header><main><article class=post><h1 class=title>BTrait - Combining Traits</h1><div class=article-details><time>Fri Jul 29 2022</time>
in
<a href=../../categories/c++>C++</a></div><div><nav id=TableOfContents><ul><li><a href=#cleanup>Cleanup</a></li><li><a href=#compile-time-dispatch-based-on-multiple-traits>Compile-time dispatch based on multiple traits</a></li><li><a href=#run-time-trait-object-based-on-multiple-traits>Run-time trait object based on multiple traits</a></li><li><a href=#supertraits>Supertraits</a></li><li><a href=#summary>Summary</a></li></ul></nav><p>In the <a href=http://meghprkh.github.io/blog/posts/btrait-cpp-rust-like-traits/>previous post</a>, we looked at how to define and implement simple traits</p><p>In this post we will look at how to combine them and pass them around, as that is what makes them really powerful. Otherwise each of them is quite basic on their own.</p><p><em>Second post of a <a href=http://meghprkh.github.io/blog/tags/series-btrait-intro/>three-post series</a></em></p><h2 id=cleanup>Cleanup</h2><p>First lets rearchitect our code and clean it up a bit</p><p>Lets redine the trait to have everything related to it:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>constexpr</span> Counter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> interpret(T<span style=color:#f92672>&amp;</span> t) {
        <span style=color:#66d9ef>return</span> Counter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> { t };
    };

    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_implemented_by</span><span style=color:#f92672>:</span> Counter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>__btrait_implemented {};

    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__btrait_abstract</span> {
        <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getCount</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    };

    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__btrait_inherit</span><span style=color:#f92672>:</span> btrait_dyn<span style=color:#f92672>&lt;</span>Counter<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>constexpr</span> <span style=color:#a6e22e>__btrait_inherit</span> (Self<span style=color:#f92672>&amp;</span> self_)<span style=color:#f92672>:</span> self(self_) {};

        <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getCount</span>() { <span style=color:#66d9ef>return</span> Counter<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>__btrait_impl_getCount(self); }
    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
        Self<span style=color:#f92672>&amp;</span> self;
    };
};
</code></pre></div><p>We define <code>btrait_dyn</code> which can be used as a dynamic trait object</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Trait<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>btrait_dyn</span><span style=color:#f92672>:</span> Trait<span style=color:#f92672>::</span>__btrait_abstract {};
</code></pre></div><p>Then to implement the trait</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span><span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;:</span> <span style=color:#66d9ef>public</span> Counter<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;::</span>__btrait_inherit<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>constexpr</span> <span style=color:#a6e22e>Counter</span> (MyCounter<span style=color:#f92672>&amp;</span> self_)<span style=color:#f92672>:</span> __btrait_inherit<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span>(self_) {};
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__btrait_implemented</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>true_type {};

<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    __attribute__((noinline)) <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> __btrait_impl_getCount(MyCounter<span style=color:#f92672>&amp;</span> self) { <span style=color:#66d9ef>return</span> self.count; }
    <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;::</span>__btrait_inherit<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span>;
};
</code></pre></div><p>With this cleanup the following is achieved:</p><ul><li>Everything starts with <code>__btrait</code> prefix. This prefix should only be used in trait definitions and implementation and not anywhere else.</li><li>Everything related to the trait definition is in one class</li><li>You cant do something like <code>Counter&lt;MyCounter>::interpret(other_type_of_counter)</code></li><li>It is explicit when you are taking a <code>dynamic reference</code> or a trait object, instead of compile time generic, as you have to state<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>traitObjectExample</span>(btrait_dyn<span style=color:#f92672>&lt;</span>Counter<span style=color:#f92672>&lt;&gt;&gt;</span> <span style=color:#f92672>&amp;</span>counter);
INSTEAD OF
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>traitObjectExample</span>(Counter<span style=color:#f92672>&lt;&gt;</span> <span style=color:#f92672>&amp;</span>counter);
</code></pre></div></li></ul><p>We have also added another trait <code>Serde</code> (serialize + deserialize). The full code can be found <a href=https://godbolt.org/z/6f6d545E8>here</a></p><details><summary>Serde trait</summary><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Serde</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>constexpr</span> Serde<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> interpret(T<span style=color:#f92672>&amp;</span> t) {
        <span style=color:#66d9ef>return</span> Serde<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> { t };
    };

    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_implemented_by</span><span style=color:#f92672>:</span> Serde<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>__btrait_implemented {};

    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__btrait_abstract</span> {
        <span style=color:#66d9ef>virtual</span> std<span style=color:#f92672>::</span>string serialize() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deserialize</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    };

    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__btrait_inherit</span><span style=color:#f92672>:</span> btrait_dyn<span style=color:#f92672>&lt;</span>Serde<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>constexpr</span> <span style=color:#a6e22e>__btrait_inherit</span> (Self<span style=color:#f92672>&amp;</span> self_)<span style=color:#f92672>:</span> self(self_) {};

        <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>virtual</span> std<span style=color:#f92672>::</span>string serialize() { <span style=color:#66d9ef>return</span> Serde<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>__btrait_impl_serialize(self); }
        <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deserialize</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> serialized) { <span style=color:#66d9ef>return</span> Serde<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>__btrait_impl_deserialize(self, serialized); }
    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
        Self<span style=color:#f92672>&amp;</span> self;
    };
};

<span style=color:#75715e>// implementation
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Serde</span><span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;:</span> <span style=color:#66d9ef>public</span> Serde<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;::</span>__btrait_inherit<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>constexpr</span> <span style=color:#a6e22e>Serde</span> (MyCounter<span style=color:#f92672>&amp;</span> self_)<span style=color:#f92672>:</span> __btrait_inherit<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span>(self_) {};
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__btrait_implemented</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>true_type {};

<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    __attribute__((noinline)) <span style=color:#66d9ef>static</span> std<span style=color:#f92672>::</span>string __btrait_impl_serialize(MyCounter<span style=color:#f92672>&amp;</span> self) { <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>to_string(self.count); }
    __attribute__((noinline)) <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> __btrait_impl_deserialize(MyCounter<span style=color:#f92672>&amp;</span> self, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string serialized) { self.count <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>stoi(serialized); }
    <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Serde</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;::</span>__btrait_inherit<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span>;
};
</code></pre></div></details><h2 id=compile-time-dispatch-based-on-multiple-traits>Compile-time dispatch based on multiple traits</h2><p>Lets assume we want to snapshot our counter every hour. We want to write a method <code>logAndSerialize</code> which would print the current value to the log and also serialize to a string that can be saved.</p><p>The parameter needs to have implemented both <code>Counter</code> and <code>Serialize</code> traits.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span>... Traits<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>btrait_require</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>conjunction<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Traits<span style=color:#f92672>::</span><span style=color:#66d9ef>template</span> is_implemented_by<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>... <span style=color:#f92672>&gt;</span> {};

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span>... Traits<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>bool</span> btrait_require_v <span style=color:#f92672>=</span> btrait_require<span style=color:#f92672>&lt;</span>T, Traits...<span style=color:#f92672>&gt;::</span>value;

<span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> CounterType<span style=color:#f92672>&gt;</span>
std<span style=color:#f92672>::</span>enable_if_t<span style=color:#f92672>&lt;</span>btrait_require_v<span style=color:#f92672>&lt;</span>CounterType, Counter<span style=color:#f92672>&lt;&gt;</span>, Serde<span style=color:#f92672>&lt;&gt;&gt;</span>, std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>
__attribute_noinline__ logAndSerialize(CounterType<span style=color:#f92672>&amp;</span> counter) {
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Serializing counter with value &#34;</span> <span style=color:#f92672>&lt;&lt;</span> Counter<span style=color:#f92672>&lt;&gt;::</span>interpret(counter).getCount() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    <span style=color:#66d9ef>return</span> Serde<span style=color:#f92672>&lt;&gt;::</span>interpret(counter).serialize();
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    MyCounter counter { <span style=color:#ae81ff>10</span> };
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Counter value &#34;</span> <span style=color:#f92672>&lt;&lt;</span> Counter<span style=color:#f92672>&lt;&gt;::</span>interpret(counter).getCount() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    std<span style=color:#f92672>::</span>string serialized <span style=color:#f92672>=</span> logAndSerialize(counter);
    counter.count <span style=color:#f92672>=</span> <span style=color:#ae81ff>25</span>;
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Before deserialization: Counter value &#34;</span> <span style=color:#f92672>&lt;&lt;</span> Counter<span style=color:#f92672>&lt;&gt;::</span>interpret(counter).getCount() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    Serde<span style=color:#f92672>&lt;&gt;::</span>interpret(counter).deserialize(serialized);
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;After deserialization: Counter value &#34;</span> <span style=color:#f92672>&lt;&lt;</span> Counter<span style=color:#f92672>&lt;&gt;::</span>interpret(counter).getCount() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>Voila! This just works! <a href=https://godbolt.org/z/rYf74GbjY>Godbolt</a></p><p>It is also possible to write complicated requires clauses using <code>conjunction</code> and <code>disjunction</code>, however it complicates things and I dont see a use-case.</p><h2 id=run-time-trait-object-based-on-multiple-traits>Run-time trait object based on multiple traits</h2><p>We want to get an trait object which implements multiple traits, eg <code>btrait_multi_dyn&lt;Counter&lt;>, Serde&lt;> ></code></p><details><summary>Ugly C++ metaprogramming code</summary><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self, <span style=color:#66d9ef>typename</span>... Traits<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>btrait_multi_dyn_specific</span>;

<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Traits<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>btrait_multi_dyn</span> {
<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Trait<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>is_in_pack</span> <span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>disjunction<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>is_same<span style=color:#f92672>&lt;</span>Trait, Traits<span style=color:#f92672>&gt;</span>...<span style=color:#f92672>&gt;</span> {};
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Trait<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>inline</span> std<span style=color:#f92672>::</span>enable_if_t<span style=color:#f92672>&lt;</span> is_in_pack<span style=color:#f92672>&lt;</span>Trait<span style=color:#f92672>&gt;::</span>value, btrait_dyn<span style=color:#f92672>&lt;</span>Trait<span style=color:#f92672>&gt;&amp;</span> <span style=color:#f92672>&gt;</span> as() {
        <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>get<span style=color:#f92672>&lt;</span>btrait_dyn<span style=color:#f92672>&lt;</span>Trait<span style=color:#f92672>&gt;&amp;&gt;</span>(dyns_);
    }

    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>static</span> std<span style=color:#f92672>::</span>enable_if_t<span style=color:#f92672>&lt;</span>btrait_require_v<span style=color:#f92672>&lt;</span>Self, Traits...<span style=color:#f92672>&gt;</span>, btrait_multi_dyn_specific<span style=color:#f92672>&lt;</span>Self, Traits...<span style=color:#f92672>&gt;&gt;</span>
    <span style=color:#66d9ef>inline</span>  interpret(Self<span style=color:#f92672>&amp;</span> self) {
        <span style=color:#66d9ef>return</span> btrait_multi_dyn_specific<span style=color:#f92672>&lt;</span>Self, Traits...<span style=color:#f92672>&gt;</span>(self);
    }

    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>static</span> std<span style=color:#f92672>::</span>enable_if_t<span style=color:#f92672>&lt;</span>btrait_require_v<span style=color:#f92672>&lt;</span>Self, Traits...<span style=color:#f92672>&gt;</span>, btrait_multi_dyn<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>inline</span> __btrait_interpret_multi_dyn_specific(btrait_multi_dyn_specific<span style=color:#f92672>&lt;</span>Self, Traits...<span style=color:#f92672>&gt;&amp;</span> specific) {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>btrait_multi_dyn</span>(std<span style=color:#f92672>::</span>tie(<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span> btrait_dyn<span style=color:#f92672>&lt;</span>Traits<span style=color:#f92672>&gt;&amp;</span> <span style=color:#f92672>&gt;</span>(
            std<span style=color:#f92672>::</span>get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>decltype</span>(Traits<span style=color:#f92672>::</span>interpret(specific.self_))<span style=color:#f92672>&gt;</span>(specific.specializations_)
        )...));
    }
<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span>btrait_dyn<span style=color:#f92672>&lt;</span>Traits<span style=color:#f92672>&gt;&amp;</span>...<span style=color:#f92672>&gt;</span> dyns_;
    btrait_multi_dyn(std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span>btrait_dyn<span style=color:#f92672>&lt;</span>Traits<span style=color:#f92672>&gt;&amp;</span>...<span style=color:#f92672>&gt;</span> dyns)<span style=color:#f92672>:</span> dyns_(dyns) {};
};


<span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self, <span style=color:#66d9ef>typename</span>... Traits<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>btrait_multi_dyn_specific</span> {
    <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>operator</span> btrait_multi_dyn<span style=color:#f92672>&lt;</span>Traits...<span style=color:#f92672>&gt;</span>()
    {
        <span style=color:#66d9ef>return</span> btrait_multi_dyn<span style=color:#f92672>&lt;</span>Traits...<span style=color:#f92672>&gt;::</span><span style=color:#66d9ef>template</span> __btrait_interpret_multi_dyn_specific<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);
    }
<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    Self<span style=color:#f92672>&amp;</span> self_;
    std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>decltype</span>(Traits<span style=color:#f92672>::</span>interpret(self_))...<span style=color:#f92672>&gt;</span> specializations_;

    <span style=color:#66d9ef>constexpr</span> <span style=color:#a6e22e>btrait_multi_dyn_specific</span>(Self<span style=color:#f92672>&amp;</span> self)<span style=color:#f92672>:</span>
        self_(self),
        specializations_(std<span style=color:#f92672>::</span>make_tuple(Traits<span style=color:#f92672>::</span>interpret(self)...))
    {}
    <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>btrait_multi_dyn</span><span style=color:#f92672>&lt;</span>Traits...<span style=color:#f92672>&gt;</span>;
};
</code></pre></div></details><p>Used as:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>__attribute_noinline__
std<span style=color:#f92672>::</span>string logAndSerializeDyn(
    btrait_multi_dyn<span style=color:#f92672>&lt;</span>Counter<span style=color:#f92672>&lt;&gt;</span>, Serde<span style=color:#f92672>&lt;&gt;</span> <span style=color:#f92672>&gt;</span> serializableCounter
) {
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Serializing counter with value &#34;</span> <span style=color:#f92672>&lt;&lt;</span> serializableCounter.as<span style=color:#f92672>&lt;</span>Counter<span style=color:#f92672>&lt;&gt;&gt;</span>().getCount() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    <span style=color:#66d9ef>return</span> serializableCounter.as<span style=color:#f92672>&lt;</span>Serde<span style=color:#f92672>&lt;&gt;&gt;</span>().serialize();
}
</code></pre></div><p>We end up with the following <a href=https://godbolt.org/z/vqj5nx1r8>full code</a></p><ul><li>It is probably not as efficient as native multiple inheritance as each trait has a &ldquo;self&rdquo; reference to be stored.</li><li>This has <code>number of traits * 2</code> extra instructions when creating this dynamic trait object - one for storing <code>self</code> and another for each <code>vtable</code></li><li>Can probably be optimized somehow maybe, at least the <code>self</code> part</li></ul><h2 id=supertraits>Supertraits</h2><p>It makes sense to define &ldquo;supertraits&rdquo; sometimes, example <code>SnapshottableCounter = Counter + Serde</code>.</p><p>This can define the additional <code>snapshot</code> method, which uses methods from the other two traits and also exposes them.</p><p>This is as easy as defining our trait&rsquo;s <code>__btrait_abstract</code> to inherit those of the other traits.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__btrait_abstract</span><span style=color:#f92672>:</span> Counter<span style=color:#f92672>&lt;&gt;::</span>__btrait_abstract, Serde<span style=color:#f92672>&lt;&gt;::</span>__btrait_abstract {
        <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>snapshot</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    };

    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__btrait_inherit</span><span style=color:#f92672>:</span> btrait_dyn<span style=color:#f92672>&lt;</span>SnapshottableCounter<span style=color:#f92672>&gt;</span> {
        <span style=color:#75715e>// Need to copy paste every method from Counter and Serde, but with changed body
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getCount</span>() { <span style=color:#66d9ef>return</span> Counter<span style=color:#f92672>&lt;&gt;::</span>interpret(self).getCount(); }
    }
    <span style=color:#66d9ef>static_assert</span>(<span style=color:#f92672>!</span>std<span style=color:#f92672>::</span>is_abstract_v<span style=color:#f92672>&lt;</span>__btrait_inherit<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span>);
</code></pre></div><p>Then it can be used as a native trait was used and <code>SnapshottableCounter::interpret(counter).getCount()</code> can be called too or passed as dyn</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>__attribute_noinline__
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>logAndSerializeDyn</span>(
    btrait_dyn<span style=color:#f92672>&lt;</span>SnapshottableCounter<span style=color:#f92672>&lt;&gt;&gt;&amp;&amp;</span> counter
) {
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;I can call counter methods &#34;</span> <span style=color:#f92672>&lt;&lt;</span> counter.getCount() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    counter.snapshot();
}

logAndSerializeDyn(SnapshottableCounter<span style=color:#f92672>&lt;&gt;::</span>interpret(counter));
</code></pre></div><p>This does put some burden on trait define-r. However the <code>static_assert</code> helps catch any missing methods and trait implementors can go about their day normally.</p><p><a href=https://godbolt.org/z/eqE5Wzq5T>Full code on Godbolt</a></p><h2 id=summary>Summary</h2><ul><li>We saw that compile time dispatching with multiple traits is very easy</li><li>Runtime multi-trait does have additional cost</li><li>Suertraits are easy to use/implement but a little cumbersome to define</li></ul><p>In the next part we will see how to define static methods and constants</p></div><div class=tags>[ Tags:
<a href=../../tags/c++>#C++</a>
<a href=../../tags/rust>#Rust</a>
<a href=../../tags/series-btrait-intro>#series-btrait-intro</a>
]</div></article><script src=https://utteranc.es/client.js repo=meghprkh/blog issue-term=pathname label=comments theme=github-light crossorigin=anonymous async></script></main><footer><p>&copy; 2022 <a href=http://meghprkh.github.io/blog/>Megh's Blog</a></p></footer></body></html>