<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>BTrait - Rust Like Traits in C++</title><link rel=stylesheet href=../../css/style.css></head><body><header class=site-header><h1>Megh's Blog</h1><nav><ul><li><a href=../../>Home</a></li><li><a href=../../categories>Categories</a></li><li><a href=../../tags>Tags</a></li><li><a href=../../about>About</a></li><li><a href=../../index.xml>Feed</a></li></ul></nav></header><main><article class=post><h1 class=title>BTrait - Rust Like Traits in C++</h1><div class=article-details><time>Thu Jul 28 2022</time>
in
<a href=../../categories/c++>C++</a></div><div><nav id=TableOfContents><ul><li><a href=#goals>Goals</a></li><li><a href=#comparision-with-c20-concepts>Comparision with C++20 concepts</a></li><li><a href=#primary-idea---traittype>Primary Idea - <code>Trait&lt;Type></code></a></li><li><a href=#initial-pass---plain-old-inheritance>Initial pass - plain old inheritance</a></li><li><a href=#improvising---using-inline-overloads-static-methods-and-crtp>Improvising - Using inline overloads, static methods and CRTP</a></li><li><a href=#trait-objects>Trait objects</a></li><li><a href=#forgetting-to-implement-a-method--adding-a-new-method-in-the-trait>Forgetting to implement a method / adding a new method in the trait</a></li><li><a href=#optimization-and-inline-guarantees>Optimization and inline guarantees</a></li><li><a href=#summary>Summary</a></li></ul></nav><p>I love Rust. Rust&rsquo;s traits are powerful yet easy-to-use abstractions. C++ interfaces are similar but not quite there. What if there was a way to implement Rust-like traits in C++? Enter <strong>BTrait</strong> - a design pattern / header-library.</p><p><em>Have I BTrayed Rust by implementing BTrait? Read on to find out more&mldr; drumrolls&mldr;</em> (Okay no more puns now)</p><p><em>First post of a <a href=http://meghprkh.github.io/blog/tags/series-btrait-intro/>three-post series</a></em></p><p>Skip directly to the <a href=http://meghprkh.github.io/blog/posts/btrait-cpp-combining-traits/>second post</a> to see it in action and skip performance related stuff.</p><h2 id=goals>Goals</h2><ul><li>To allow:<ul><li>Defining traits - small collections of methods, typedefs and constants</li><li>Implementing traits - even if we do not own the class.<ul><li>For example, we want to implement <code>to_json</code> for <code>std::vector</code></li></ul></li><li>Compile-time Dispatching/overloading based on if Trait is implemented</li><li>Runtime Trait Objects - storing pointers or references of trait implementors</li></ul></li><li>To not add any runtime cost, with a basic <code>-O1</code> optimization level on gcc and clang</li><li>While we use C++17, most of our code is compatible with C++03 (and some basic Boost)</li><li>To allow defining the actual trait implementation is a separate compile unit<ul><li>Defining a method with <code>__attribute_noinline__</code> is the same as putting it in a separate compile unit for our purposes</li></ul></li></ul><h2 id=comparision-with-c20-concepts>Comparision with C++20 concepts</h2><ul><li>We want to target old C++ versions</li><li>C++ concepts are quite flexible features but lack some of the simplicity</li><li>Cant create &ldquo;trait objects&rdquo; or &ldquo;concept objects&rdquo;, i.e. how to store a vector of heteogeneous references?</li><li>Combining concepts and &ldquo;Super-concepts&rdquo; as we see in part two is hard</li></ul><h2 id=primary-idea---traittype>Primary Idea - <code>Trait&lt;Type></code></h2><p>If we implement our trait as a template taking the type:</p><ul><li>We can implement it without modifying the Type/Class</li><li>We can implement it without adding a vtable to the class</li><li>We can possibly combine multiple traits easily</li></ul><h2 id=initial-pass---plain-old-inheritance>Initial pass - plain old inheritance</h2><p>We will try to use plain old inheritance here:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// declare trait
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T <span style=color:#f92672>=</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span> {
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>implemented</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>false_type {};
};

<span style=color:#75715e>// define trait
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span><span style=color:#f92672>&lt;&gt;</span> {
    <span style=color:#75715e>// Read as - allow this static method if T implements Counter
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Will return a Counter&lt;T&gt;
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
    <span style=color:#66d9ef>static</span> std<span style=color:#f92672>::</span>enable_if_t<span style=color:#f92672>&lt;</span>Counter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>implemented<span style=color:#f92672>::</span>value, Counter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span>
    interpret(T<span style=color:#f92672>&amp;</span> self) { <span style=color:#66d9ef>return</span> Counter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(self); }

    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getCount</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
};

<span style=color:#75715e>// declare and define our struct
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyCounter</span> {
    <span style=color:#66d9ef>int</span> count;
};

<span style=color:#75715e>// implement trait for our struct
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span><span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;:</span> Counter<span style=color:#f92672>&lt;&gt;</span> {
    Counter(MyCounter<span style=color:#f92672>&amp;</span> self)<span style=color:#f92672>:</span> self_(self) {}
    <span style=color:#66d9ef>virtual</span> __attribute_noinline__ <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getCount</span>() { <span style=color:#66d9ef>return</span> self_.count; };
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>implemented</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>true_type {};
<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    MyCounter<span style=color:#f92672>&amp;</span> self_;
};

<span style=color:#75715e>// struct without any trait stuff
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>NoTraitCounter</span> {
    <span style=color:#66d9ef>int</span> count;
    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getCount</span>() __attribute_noinline__ { <span style=color:#66d9ef>return</span> count; }
};

<span style=color:#75715e>// Dispatched when trait is implemented
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
std<span style=color:#f92672>::</span>enable_if_t<span style=color:#f92672>&lt;</span>Counter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>implemented<span style=color:#f92672>::</span>value, <span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>
__attribute_noinline__
printCounter(T<span style=color:#f92672>&amp;</span> counter) {
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> Counter<span style=color:#f92672>&lt;&gt;::</span>interpret(counter).getCount() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
}

<span style=color:#75715e>// Dispatched when trait not implemented
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
std<span style=color:#f92672>::</span>enable_if_t<span style=color:#f92672>&lt;!</span>Counter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>implemented<span style=color:#f92672>::</span>value, <span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>
__attribute_noinline__
printCounter(T<span style=color:#f92672>&amp;</span> counter) {
    <span style=color:#75715e>// Hope that method is implemented, else this will fail to compile
</span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> counter.getCount() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
}

<span style=color:#75715e>// check
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    MyCounter mycounter { <span style=color:#ae81ff>25</span> };
    NoTraitCounter ntcounter { <span style=color:#ae81ff>10</span> };
    printCounter(mycounter);
    printCounter(ntcounter);
}
</code></pre></div><p>If we put <a href=https://godbolt.org/z/87vMWcjrW>this code on Godbolt</a>, we see that it does work perfectly, but has a few regressions:</p><ul><li><code>Counter&lt;MyCounter>::getCount()</code> has an additional parameter (1 extra instruction)<ul><li>Evident from the extra <code>mov rax, QWORD PTR [rdi+8]</code></li><li>This is because C++ passes <code>this</code> as the first parameter, and even if a struct has no data members, its address can be used to do stuff in methods.</li></ul></li><li><code>printCounter&lt;MyCounter>(MyCounter&)</code> has 3 more instructions<ul><li>As compared to <code>printCounter&lt;NoTraitCounter>(NoTraitCounter&)</code></li><li>The following comes from having to construct <code>this</code> which has a <code>vtable</code> and a reference to <code>self_</code> / <code>mycounter</code><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=color:#a6e22e>mov</span>     <span style=color:#66d9ef>QWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>rsp</span>], <span style=color:#66d9ef>OFFSET</span> <span style=color:#66d9ef>FLAT</span>:<span style=color:#66d9ef>vtable</span> <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>Counter</span><span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#66d9ef>MyCounter</span><span style=color:#960050;background-color:#1e0010>&gt;+</span><span style=color:#ae81ff>16</span>
<span style=color:#a6e22e>mov</span>     <span style=color:#66d9ef>QWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>rsp</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>8</span>], <span style=color:#66d9ef>rdi</span>
</code></pre></div></li><li>The following comes from having to load this newly constructed <code>this</code> as the first parameter to the call<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=color:#a6e22e>mov</span>     <span style=color:#66d9ef>rdi</span>, <span style=color:#66d9ef>rsp</span>
</code></pre></div></li><li>Note that since <code>getCount</code> would be implemented in another CPP file / compile-unit, the compiler can do nothing smart about it and skip construction/loading of <code>this</code></li></ul></li></ul><h2 id=improvising---using-inline-overloads-static-methods-and-crtp>Improvising - Using inline overloads, static methods and CRTP</h2><ul><li>Static methods do not take a <code>this</code> pointer</li><li>Inheritance does not really allow us to omit <code>this</code></li></ul><p>Lets add the following new class - this will always be inlined and live in a header file</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// Self would refer type being implemented for, &#34;MyCounter&#34; for example
</span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Self<span style=color:#f92672>&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CounterDefaultImpl</span><span style=color:#f92672>:</span> Counter<span style=color:#f92672>&lt;&gt;</span> {
    CounterDefaultImpl(Self<span style=color:#f92672>&amp;</span> self)<span style=color:#f92672>:</span> self_(self) {}

    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getCount</span>() <span style=color:#66d9ef>override</span> { <span style=color:#66d9ef>return</span> Counter<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>_impl_getCount(self_); };
<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    Self<span style=color:#f92672>&amp;</span> self_;
};
</code></pre></div><p>And change the implementation of <code>Counter&lt;MyCounter></code> to inherit it</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span><span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;:</span> CounterDefaultImpl<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span> {
    Counter(MyCounter<span style=color:#f92672>&amp;</span> self)<span style=color:#f92672>:</span> CounterDefaultImpl<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span>(self) {}
    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>implemented</span><span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>true_type {};
<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> _impl_getCount(MyCounter<span style=color:#f92672>&amp;</span> self) __attribute_noinline__ { <span style=color:#66d9ef>return</span> self.count; };
    <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterDefaultImpl</span><span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span>;
};
</code></pre></div><p>What we have effectively done is moved the construction and usage of <code>this</code> to a stub method and the core implementation to a static method that takes <code>self</code> as the parameter</p><p>Putting <a href=https://godbolt.org/z/dYcM8oEKq>this on godbolt</a> we see that both implementations now have the <strong>exact same code generated</strong>! Hooray, we have implemented a basic version of traits!!</p><h2 id=trait-objects>Trait objects</h2><p>We can still pass this like we used to do in inheritance to save some compilation overhead. We can also store this reference or raw pointer in an vector for example.</p><p>For example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>traitObjectExample</span>(Counter<span style=color:#f92672>&lt;&gt;</span> <span style=color:#f92672>&amp;</span>counter) {
    <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> counter.getCount();
    all_counters.push_back(counter);
}

<span style=color:#66d9ef>auto</span> mycounter_trait <span style=color:#f92672>=</span> Counter<span style=color:#f92672>&lt;&gt;::</span>interpret(mycounter); <span style=color:#75715e>// type is Counter&lt;MyCounter&gt;
</span><span style=color:#75715e></span>traitObjectExample(<span style=color:#f92672>&amp;</span>mycounter_trait);
</code></pre></div><h2 id=forgetting-to-implement-a-method--adding-a-new-method-in-the-trait>Forgetting to implement a method / adding a new method in the trait</h2><p>This will give us an easy to read error - even if we do not actually use the method - <a href=https://godbolt.org/z/KoGjeYcac>Godbolt</a></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#f92672>&lt;</span>source<span style=color:#f92672>&gt;:</span> In instantiation of <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#66d9ef>int</span> CounterDefaultImpl<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>getCount() [with Self <span style=color:#f92672>=</span> MyCounter]<span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#f92672>:</span>
<span style=color:#f92672>&lt;</span>source<span style=color:#f92672>&gt;:</span><span style=color:#ae81ff>24</span><span style=color:#f92672>:</span><span style=color:#ae81ff>17</span><span style=color:#f92672>:</span>   required from here
<span style=color:#f92672>&lt;</span>source<span style=color:#f92672>&gt;:</span><span style=color:#ae81ff>24</span><span style=color:#f92672>:</span><span style=color:#ae81ff>75</span><span style=color:#f92672>:</span> error: <span style=color:#960050;background-color:#1e0010>&#39;</span>_impl_getCount<span style=color:#960050;background-color:#1e0010>&#39;</span> is not a member of <span style=color:#960050;background-color:#1e0010>&#39;</span>Counter<span style=color:#f92672>&lt;</span>MyCounter<span style=color:#f92672>&gt;</span><span style=color:#960050;background-color:#1e0010>&#39;</span>
   <span style=color:#ae81ff>24</span> <span style=color:#f92672>|</span>     <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int</span> getCount() <span style=color:#66d9ef>override</span> { <span style=color:#66d9ef>return</span> Counter<span style=color:#f92672>&lt;</span>Self<span style=color:#f92672>&gt;::</span>_impl_getCount(self_); };
      <span style=color:#f92672>|</span>                                              <span style=color:#f92672>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~</span>
ASM generation compiler returned: <span style=color:#ae81ff>1</span>
</code></pre></div><h2 id=optimization-and-inline-guarantees>Optimization and inline guarantees</h2><ul><li>We compiled with <code>-O1</code> to ensure the compiler inlines our code</li><li>But what if it didnt?</li><li><code>constexpr</code> those methods, helps optimization</li><li>With required copy elision and optimization, it should still be fast. <a href=https://godbolt.org/z/szTxqKn47>Godbolt</a> shows 3 extra instructions.</li><li><code>-Winline</code> can show warnings in gcc</li><li>Compiler attributes that should be added - <code>__attribute__((__always_inline__))</code> or <code>__forceinline</code></li><li>These have not been written in above code for simplicity</li><li><a href=https://godbolt.org/z/8fzjabGec>Clang</a> and <a href=https://godbolt.org/z/8fzjabGec>GCC</a> have no issues keeping up</li><li><a href=https://en.wikipedia.org/wiki/Inline_function#Restrictions>MSVC</a> has this problem especially because it cant inline a virtual function, generating 4 more instructions - <a href=https://godbolt.org/z/KEb5r31nn>Godbolt</a></li></ul><p>We can get completely rid of this by making the static <code>impl</code> methods public. And directly requiring calls to call <code>Counter&lt;MyCounter>::impl_getCount(mycounter)</code></p><p>This can also be prettified using some more advanced metaprogramming I guess, maybe user-defined literals or macros for older C++? The extra cost would still be associated with dynamic passing.</p><h2 id=summary>Summary</h2><ul><li>We could implement a simple trait with no performance loss</li><li>We could also implement a trait for an object we do not own<ul><li>We can make the implementor a friend class to access private members if we own the class</li></ul></li><li>In the next post we will declare combinations of traits and discuss storing these as &ldquo;trait objects&rdquo;</li><li>We will also discuss what methods are not &ldquo;trait object safe&rdquo; and how to handle them</li><li>This includes discussion of traits with &ldquo;other static methods&rdquo; or constants</li></ul></div><div class=tags>[ Tags:
<a href=../../tags/c++>#C++</a>
<a href=../../tags/rust>#Rust</a>
<a href=../../tags/series-btrait-intro>#series-btrait-intro</a>
]</div></article><script src=https://utteranc.es/client.js repo=meghprkh/blog issue-term=pathname label=comments theme=github-light crossorigin=anonymous async></script></main><footer><p>&copy; 2022 <a href=http://meghprkh.github.io/blog/>Megh's Blog</a></p></footer></body></html>